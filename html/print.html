<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Nix Pills</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="00-preface.html">Preface</a></li><li class="chapter-item expanded "><a href="01-why-you-should-give-it-try.html"><strong aria-hidden="true">1.</strong> Why You Should Give it a Try</a></li><li class="chapter-item expanded "><a href="02-install-on-your-running.html"><strong aria-hidden="true">2.</strong> Install on Your Running System</a></li><li class="chapter-item expanded "><a href="03-enter-environment.html"><strong aria-hidden="true">3.</strong> Enter the Environment</a></li><li class="chapter-item expanded "><a href="04-basics-of-language.html"><strong aria-hidden="true">4.</strong> The Basics of the Language</a></li><li class="chapter-item expanded "><a href="05-functions-and-imports.html"><strong aria-hidden="true">5.</strong> Functions and Imports</a></li><li class="chapter-item expanded "><a href="06-our-first-derivation.html"><strong aria-hidden="true">6.</strong> Our First Derivation</a></li><li class="chapter-item expanded "><a href="07-working-derivation.html"><strong aria-hidden="true">7.</strong> Working Derivation</a></li><li class="chapter-item expanded "><a href="08-generic-builders.html"><strong aria-hidden="true">8.</strong> Generic Builders</a></li><li class="chapter-item expanded "><a href="09-automatic-runtime.html"><strong aria-hidden="true">9.</strong> Automatic Runtime Dependencies</a></li><li class="chapter-item expanded "><a href="10-developing-with-nix-shell.html"><strong aria-hidden="true">10.</strong> Developing with nix-shell</a></li><li class="chapter-item expanded "><a href="11-garbage-collector.html"><strong aria-hidden="true">11.</strong> The Garbage Collector</a></li><li class="chapter-item expanded "><a href="12-inputs-design-pattern.html"><strong aria-hidden="true">12.</strong> Package Repositories and the Inputs Design Pattern</a></li><li class="chapter-item expanded "><a href="13-callpackage-design-pattern.html"><strong aria-hidden="true">13.</strong> Callpackage Design Pattern</a></li><li class="chapter-item expanded "><a href="14-override-design-pattern.html"><strong aria-hidden="true">14.</strong> Override Design Pattern</a></li><li class="chapter-item expanded "><a href="15-nix-search-paths.html"><strong aria-hidden="true">15.</strong> Nix Search Paths</a></li><li class="chapter-item expanded "><a href="16-nixpkgs-parameters.html"><strong aria-hidden="true">16.</strong> Nixpkgs Parameters</a></li><li class="chapter-item expanded "><a href="17-nixpkgs-overriding-packages.html"><strong aria-hidden="true">17.</strong> Nixpkgs Overriding Packages</a></li><li class="chapter-item expanded "><a href="18-nix-store-paths.html"><strong aria-hidden="true">18.</strong> Nix Store Paths</a></li><li class="chapter-item expanded "><a href="19-fundamentals-of-stdenv.html"><strong aria-hidden="true">19.</strong> Fundamentals of Stdenv</a></li><li class="chapter-item expanded "><a href="20-basic-dependencies-and-hooks.html"><strong aria-hidden="true">20.</strong> Basic Dependencies and Hooks</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Nix Pills</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <hr />
<h2 id="title-nix-pills"><a class="header" href="#title-nix-pills">title: Nix Pills</a></h2>
<h1 id="preface"><a class="header" href="#preface">Preface</a></h1>
<p>This is a ported version of the <strong>Nix Pills</strong>, a series of blog posts
written by <strong>Luca Bruno</strong> (aka Lethalman) and originally published in
2014 and 2015. It provides a tutorial introduction into the Nix package
manager and Nixpkgs package collection, in the form of short chapters
called 'pills'.</p>
<p>Since the Nix Pills are considered a classic introduction to Nix, an
effort to port them to the current format was led by Graham Christensen
(aka grahamc / gchristensen) and other contributors in 2017.</p>
<p>For an up-to-date version, please visit
<a href="https://nixos.org/guides/nix-pills/">https://nixos.org/guides/nix-pills/</a>. An <a href="https://nixos.org/guides/nix-pills/nix-pills.epub">EPUB
version</a> is also
available.</p>
<p>If you encounter problems, please report them on the
<a href="https://github.com/NixOS/nix-pills/issues">nixos/nix-pills</a> issue
tracker.</p>
<div class="info">
<p>Note: Commands prefixed with <code>#</code> have to be run as root, either requiring to
login as root user or temporarily switching to it using <code>sudo</code> for
example.</p>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="why-you-should-give-it-a-try"><a class="header" href="#why-you-should-give-it-a-try">Why You Should Give it a Try</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Welcome to the first post of the "<a href="https://nixos.org/nix">Nix</a> in
pills" series. Nix is a purely functional package manager and
deployment system for POSIX.</p>
<p>There's a lot of documentation that describes what Nix,
<a href="https://nixos.org/nixos">NixOS</a> and related projects are. But the
purpose of this post is to convince you to give Nix a try. Installing
NixOS is not required, but sometimes I may refer to NixOS as a real
world example of Nix usage for building a whole operating system.</p>
<h2 id="rationale-for-this-series"><a class="header" href="#rationale-for-this-series">Rationale for this series</a></h2>
<p>The <a href="https://nixos.org/manual/nix">Nix</a>,
<a href="https://nixos.org/manual/nixpkgs/">Nixpkgs</a>, and
<a href="https://nixos.org/manual/nixos/">NixOS</a> manuals along with <a href="https://nixos.wiki/">the
wiki</a> are excellent resources for explaining how
Nix/NixOS works, how you can use it, and how cool things are being done
with it. However, at the beginning you may feel that some of the magic
which happens behind the scenes is hard to grasp.</p>
<p>This series aims to complement the existing explanations from the more
formal documents.</p>
<p>The following is a description of Nix. Just as with pills, I'll try to
be as short as possible.</p>
<h2 id="not-being-purely-functional"><a class="header" href="#not-being-purely-functional">Not being purely functional</a></h2>
<p>Most, if not all, widely used package managers
(<a href="https://wiki.debian.org/dpkg">dpkg</a>, <a href="http://www.rpm.org/">rpm</a>, ...)
mutate the global state of the system. If a package <code>foo-1.0</code> installs a
program to <code>/usr/bin/foo</code>, you cannot install <code>foo-1.1</code> as well, unless
you change the installation paths or the binary name. But changing the
binary names means breaking users of that binary.</p>
<p>There are some attempts to mitigate this problem. Debian, for example,
partially solves the problem with the
<a href="https://wiki.debian.org/DebianAlternatives">alternatives</a> system.</p>
<p>So while in theory it's possible with some current systems to install
multiple versions of the same package, in practice it's very painful.</p>
<p>Let's say you need an nginx service and also an nginx-openresty
service. You have to create a new package that changes all the paths to
have, for example, an <code>-openresty</code> suffix.</p>
<p>Or suppose that you want to run two different instances of mysql: 5.2
and 5.5. The same thing applies, plus you have to also make sure the two
mysqlclient libraries do not collide.</p>
<p>This is not impossible but it <em>is</em> very inconvenient. If you want to
install two whole stacks of software like GNOME 3.10 and GNOME 3.12, you
can imagine the amount of work.</p>
<p>From an administrator's point of view: you can use containers. The
typical solution nowadays is to create a container per service,
especially when different versions are needed. That somewhat solves the
problem, but at a different level and with other drawbacks. For example,
needing orchestration tools, setting up a shared cache of packages, and
new machines to monitor rather than simple services.</p>
<p>From a developer's point of view: you can use virtualenv for python, or
jhbuild for gnome, or whatever else. But then how do you mix the two
stacks? How do you avoid recompiling the same thing when it could
instead be shared? Also you need to set up your development tools to
point to the different directories where libraries are installed. Not
only that, there's the risk that some of the software incorrectly uses
system libraries.</p>
<p>And so on. Nix solves all this at the packaging level and solves it
well. A single tool to rule them all.</p>
<h2 id="being-purely-functional"><a class="header" href="#being-purely-functional">Being purely functional</a></h2>
<p>Nix makes no assumptions about the global state of the system. This has
many advantages, but also some drawbacks of course. The core of a Nix
system is the Nix store, usually installed under <code>/nix/store</code>, and some
tools to manipulate the store. In Nix there is the notion of a
<em>derivation</em> rather than a package. The difference can be subtle at the
beginning, so I will often use the words interchangeably.</p>
<p>Derivations/packages are stored in the Nix store as follows:
<code>/nix/store/hash-name</code>, where the hash uniquely identifies the
derivation (this isn't quite true, it's a little more complex), and
the name is the name of the derivation.</p>
<p>Let's take a bash derivation as an example:
<code>/nix/store/s4zia7hhqkin1di0f187b79sa2srhv6k-bash-4.2-p45/</code>. This is a
directory in the Nix store which contains <code>bin/bash</code>.</p>
<p>What that means is that there's no <code>/bin/bash</code>, there's only that
self-contained build output in the store. The same goes for coreutils
and everything else. To make them convenient to use from the shell, Nix
will arrange for binaries to appear in your <code>PATH</code> as appropriate.</p>
<p>What we have is basically a store of all packages (with different
versions occupying different locations), and everything in the Nix store
is immutable.</p>
<p>In fact, there's no ldconfig cache either. So where does bash find
libc?</p>
<pre><code>$ ldd  `which bash`
libc.so.6 =&gt; /nix/store/94n64qy99ja0vgbkf675nyk39g9b978n-glibc-2.19/lib/libc.so.6 (0x00007f0248cce000)
</code></pre>
<p>It turns out that when bash was built, it was built against that
specific version of glibc in the Nix store, and at runtime it will
require exactly that glibc version.</p>
<p>Don't be confused by the version in the derivation name: it's only a
name for us humans. You may end up having two derivations with the same
name but different hashes: it's the hash that really matters.</p>
<p>What does all this mean? It means that you could run mysql 5.2 with
glibc-2.18, and mysql 5.5 with glibc-2.19. You could use your python
module with python 2.7 compiled with gcc 4.6 and the same python module
with python 3 compiled with gcc 4.8, all in the same system.</p>
<p>In other words: no dependency hell, not even a dependency resolution
algorithm. Straight dependencies from derivations to other derivations.</p>
<p>From an administrator's point of view: if you want an old PHP version
for one application, but want to upgrade the rest of the system, that's
not painful any more.</p>
<p>From a developer's point of view: if you want to develop webkit with
llvm 3.4 and 3.3, that's not painful any more.</p>
<h2 id="mutable-vs-immutable"><a class="header" href="#mutable-vs-immutable">Mutable vs. immutable</a></h2>
<p>When upgrading a library, most package managers replace it in-place. All
new applications run afterwards with the new library without being
recompiled. After all, they all refer dynamically to <code>libc6.so</code>.</p>
<p>Since Nix derivations are immutable, upgrading a library like glibc
means recompiling all applications, because the glibc path to the Nix
store has been hardcoded.</p>
<p>So how do we deal with security updates? In Nix we have some tricks
(still pure) to solve this problem, but that's another story.</p>
<p>Another problem is that unless software has in mind a pure functional
model, or can be adapted to it, it can be hard to compose applications
at runtime.</p>
<p>Let's take Firefox for example. On most systems, you install flash, and
it starts working in Firefox because Firefox looks in a global path for
plugins.</p>
<p>In Nix, there's no such global path for plugins. Firefox therefore must
know explicitly about the path to flash. The way we handle this problem
is to wrap the Firefox binary so that we can setup the necessary
environment to make it find flash in the nix store. That will produce a
new Firefox derivation: be aware that it takes a few seconds, and it
makes composition harder at runtime.</p>
<p>There are no upgrade/downgrade scripts for your data. It doesn't make
sense with this approach, because there's no real derivation to be
upgraded. With Nix you switch to using other software with its own stack
of dependencies, but there's no formal notion of upgrade or downgrade
when doing so.</p>
<p>If there is a data format change, then migrating to the new data format
remains your own responsibility.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Nix lets you compose software at build time with maximum flexibility,
and with builds being as reproducible as possible. Not only that, due to
its nature deploying systems in the cloud is so easy, consistent, and
reliable that in the Nix world all existing self-containment and
orchestration tools are deprecated by
<a href="http://nixos.org/nixops/">NixOps</a>.</p>
<p>It however <em>currently</em> falls short when working with dynamic composition
at runtime or replacing low level libraries, due to the need to rebuild
dependencies.</p>
<p>That may sound scary, however after running NixOS on both a server and a
laptop desktop, I'm very satisfied so far. Some of the architectural
problems just need some man-power, other design problems still need to
be solved as a community.</p>
<p>Considering <a href="https://nixos.org/nixpkgs/">Nixpkgs</a> (<a href="https://github.com/NixOS/nixpkgs">github
link</a>) is a completely new repository
of all the existing software, with a completely fresh concept, and with
few core developers but overall year-over-year increasing contributions,
the current state is more than acceptable and beyond the experimental
stage. In other words, it's worth your investment.</p>
<h2 id="next-pill"><a class="header" href="#next-pill">Next pill...</a></h2>
<p>...we will install Nix on top of your current system (I assume
GNU/Linux, but we also have OSX users) and start inspecting the
installed software.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="install-on-your-running-system"><a class="header" href="#install-on-your-running-system">Install on Your Running System</a></h1>
<p>Welcome to the second Nix pill. In the
<a href="01-why-you-should-give-it-try.html">first</a> pill we briefly described Nix.</p>
<p>Now we'll install Nix on our running system and understand what changed
in our system after the installation. <strong>If you're using NixOS, Nix is
already installed; you can skip to the <a href="03-enter-environment.html">next</a>
pill.</strong></p>
<p>For installation instructions, please refer to the Nix Reference Manual
on <a href="https://nixos.org/manual/nix/stable/installation/installing-binary.html"> Installing
Nix</a>.</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>These articles are not a tutorial on <em>using</em> Nix. Instead, we're going
to walk through the Nix system to understand the fundamentals.</p>
<p>The first thing to note: derivations in the Nix store refer to other
derivations which are themselves in the Nix store. They don't use
<code>libc</code> from our system or anywhere else. It's a self-contained store of
all the software we need to bootstrap up to any particular package.</p>
<div class="info">
<p>Note: In a multi-user installation, such as the one used in NixOS, the store
is owned by root and multiple users can install and build software
through a Nix daemon. You can read more about multi-user installations
here:
<a href="https://nixos.org/manual/nix/stable/installation/installing-binary.html#multi-user-installation">https://nixos.org/manual/nix/stable/installation/installing-binary.html#multi-user-installation</a>.</p>
</div>
<h2 id="the-beginnings-of-the-nix-store"><a class="header" href="#the-beginnings-of-the-nix-store">The beginnings of the Nix store</a></h2>
<p>Start looking at the output of the install command:</p>
<pre><code>copying Nix to /nix/store..........................
</code></pre>
<p>That's the <code>/nix/store</code> we were talking about in the first article.
We're copying in the necessary software to bootstrap a Nix system. You
can see bash, coreutils, the C compiler toolchain, perl libraries,
sqlite and Nix itself with its own tools and libnix.</p>
<p>You may have noticed that <code>/nix/store</code> can contain not only directories,
but also files, still always in the form &lt;hash-name&gt;.</p>
<h2 id="the-nix-database"><a class="header" href="#the-nix-database">The Nix database</a></h2>
<p>Right after copying the store, the installation process initializes a
database:</p>
<pre><code>initialising Nix database...
</code></pre>
<p>Yes, Nix also has a database. It's stored under <code>/nix/var/nix/db</code>. It
is a sqlite database that keeps track of the dependencies between
derivations.</p>
<p>The schema is very simple: there's a table of valid paths, mapping from
an auto increment integer to a store path.</p>
<p>Then there's a dependency relation from path to paths upon which they
depend.</p>
<p>You can inspect the database by installing sqlite
(<code>nix-env -iA sqlite -f '&lt;nixpkgs&gt;'</code>) and then running
<code>sqlite3 /nix/var/nix/db/db.sqlite</code>.</p>
<div class="info">
<p>Note: If this is the first time you're using Nix after the initial
installation, remember you must close and open your terminals first, so
that your shell environment will be updated.</p>
</div>
<div class="warning">
<p>Important: Never change <code>/nix/store</code> manually. If you do, then it will no longer be
in sync with the sqlite db, unless you <em>really</em> know what you are doing.</p>
</div>
<h2 id="the-first-profile"><a class="header" href="#the-first-profile">The first profile</a></h2>
<p>Next in the installation, we encounter the concept of the
<a href="https://nixos.org/manual/nix/stable/package-management/profiles.html">profile</a>:</p>
<pre><code class="hljs">creating /home/nix/.nix-profile
installing 'nix-2.1.3'
building path(s) `/nix/store/a7p1w3z2h8pl00ywvw6icr3g5l9vm5r7-<b>user-environment</b>'
created 7 symlinks in user environment
</code></pre>
<p>A profile in Nix is a general and convenient concept for realizing
rollbacks. Profiles are used to compose components that are spread among
multiple paths under a new unified path. Not only that, but profiles are
made up of multiple "generations": they are versioned. Whenever you
change a profile, a new generation is created.</p>
<p>Generations can be switched and rolled back atomically, which makes them
convenient for managing changes to your system.</p>
<p>Let's take a closer look at our profile:</p>
<pre><code class="hljs">$ ls -l ~/.nix-profile/
bin -> /nix/store/ig31y9gfpp8pf3szdd7d4sf29zr7igbr-<b>nix-2.1.3</b>/bin
[...]
manifest.nix -> /nix/store/q8b5238akq07lj9gfb3qb5ycq4dxxiwm-<b>env-manifest.nix</b>
[...]
share -> /nix/store/ig31y9gfpp8pf3szdd7d4sf29zr7igbr-<b>nix-2.1.3</b>/share
</code></pre>
<p>That nix-2.1.3 derivation in the Nix store is Nix itself, with binaries
and libraries. The process of "installing" the derivation in the
profile basically reproduces the hierarchy of the nix-2.1.3 store
derivation in the profile by means of symbolic links.</p>
<p>The contents of this profile are special, because only one program has
been installed in our profile, therefore e.g. the <code>bin</code> directory points
to the only program which has been installed (Nix itself).</p>
<p>But that's only the contents of the latest generation of our profile.
In fact, <code>~/.nix-profile</code> itself is a symbolic link to
<code>/nix/var/nix/profiles/default</code>.</p>
<p>In turn, that's a symlink to <code>default-1-link</code> in the same directory.
Yes, that means it's the first generation of the <code>default</code> profile.</p>
<p>Finally, <code>default-1-link</code> is a symlink to the nix store
"user-environment" derivation that you saw printed during the
installation process.</p>
<p>We'll talk about <code>manifest.nix</code> more in the next article.</p>
<h2 id="nixpkgs-expressions"><a class="header" href="#nixpkgs-expressions">Nixpkgs expressions</a></h2>
<p>More output from the installer:</p>
<pre><code>downloading Nix expressions from `http://releases.nixos.org/nixpkgs/nixpkgs-14.10pre46060.a1a2851/nixexprs.tar.xz'...
unpacking channels...
created 2 symlinks in user environment
modifying /home/nix/.profile...
</code></pre>
<p>Nix expressions are written in the <a href="https://nix.dev/tutorials/nix-language">Nix
language</a> and used to describe
packages and how to build them. <a href="https://nixos.org/nixpkgs/">Nixpkgs</a> is
the repository containing all of the expressions:
<a href="https://github.com/NixOS/nixpkgs">https://github.com/NixOS/nixpkgs</a>.</p>
<p>The installer downloaded the package descriptions from commit <code>a1a2851</code>.</p>
<p>The second profile we discover is the channels profile.
<code>~/.nix-defexpr/channels</code> points to
<code>/nix/var/nix/profiles/per-user/nix/channels</code> which points to
<code>channels-1-link</code> which points to a Nix store directory containing the
downloaded Nix expressions.</p>
<p>Channels are a set of packages and expressions available for download.
Similar to Debian stable and unstable, there's a stable and unstable
channel. In this installation, we're tracking <code>nixpkgs-unstable</code>.</p>
<p>Don't worry about Nix expressions yet, we'll get to them later.</p>
<p>Finally, for your convenience, the installer modified <code>~/.profile</code> to
automatically enter the Nix environment. What
<code>~/.nix-profile/etc/profile.d/nix.sh</code> really does is simply to add
<code>~/.nix-profile/bin</code> to <code>PATH</code> and <code>~/.nix-defexpr/channels/nixpkgs</code> to
<code>NIX_PATH</code>. We'll discuss <code>NIX_PATH</code> later.</p>
<p>Read <code>nix.sh</code>, it's short.</p>
<h2 id="faq-can-i-change-nix-to-something-else"><a class="header" href="#faq-can-i-change-nix-to-something-else">FAQ: Can I change /nix to something else?</a></h2>
<p>You can, but there's a good reason to keep using <code>/nix</code> instead of a
different directory. All the derivations depend on other derivations by
using absolute paths. We saw in the first article that bash referenced a
glibc under a specific absolute path in <code>/nix/store</code>.</p>
<p>You can see for yourself, don't worry if you see multiple bash
derivations:</p>
<pre><code>$ ldd /nix/store/*bash*/bin/bash
[...]
</code></pre>
<p>Keeping the store in <code>/nix</code> means we can grab the binary cache from
nixos.org (just like you grab packages from debian mirrors) otherwise:</p>
<ul>
<li>
<p>glibc would be installed under <code>/foo/store</code></p>
</li>
<li>
<p>Thus bash would need to point to glibc under <code>/foo/store</code>, instead
of under <code>/nix/store</code></p>
</li>
<li>
<p>So the binary cache can't help, because we need a <em>different</em> bash,
and so we'd have to recompile everything ourselves.</p>
</li>
</ul>
<p>After all <code>/nix</code> is a sensible place for the store.</p>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>We've installed Nix on our system, fully isolated and owned by the
<code>nix</code> user as we're still coming to terms with this new system.</p>
<p>We learned some new concepts like profiles and channels. In particular,
with profiles we're able to manage multiple generations of a
composition of packages, while with channels we're able to download
binaries from <code>nixos.org</code>.</p>
<p>The installation put everything under <code>/nix</code>, and some symlinks in the
Nix user home. That's because every user is able to install and use
software in her own environment.</p>
<p>I hope I left nothing uncovered so that you think there's some kind of
magic going on behind the scenes. It's all about putting components in
the store and symlinking these components together.</p>
<h2 id="next-pill-1"><a class="header" href="#next-pill-1">Next pill...</a></h2>
<p>...we will enter the Nix environment and learn how to interact with the
store.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enter-environment"><a class="header" href="#enter-environment">Enter the Environment</a></h1>
<p>Welcome to the third Nix pill. In the <a href="02-install-on-your-running.html">second
pill</a> we installed Nix on our running
system. Now we can finally play with it a little, these things also
apply to NixOS users.</p>
<h2 id="enter-the-environment"><a class="header" href="#enter-the-environment">Enter the environment</a></h2>
<p><strong>If you're using NixOS, you can skip to the <a href="03-enter-environment.html#install-something">next</a>
step.</strong></p>
<p>In the previous article we created a Nix user, so let's start by
switching to it with <code>su - nix</code>. If your <code>~/.profile</code> got evaluated,
then you should now be able to run commands like <code>nix-env</code> and
<code>nix-store</code>.</p>
<p>If that's not the case:</p>
<pre><code>$ source ~/.nix-profile/etc/profile.d/nix.sh
</code></pre>
<p>To remind you, <code>~/.nix-profile/etc</code> points to the <code>nix-2.1.3</code>
derivation. At this point, we are in our Nix user profile.</p>
<h2 id="install-something"><a class="header" href="#install-something">Install something</a></h2>
<p>Finally something practical! Installation into the Nix environment is an
interesting process. Let's install <code>hello</code>, a simple CLI tool which
prints <code>Hello world</code> and is mainly used to test compilers and package
installations.</p>
<p>Back to the installation:</p>
<pre><code>$ nix-env -i hello
installing 'hello-2.10'
[...]
building '/nix/store/0vqw0ssmh6y5zj48yg34gc6macr883xk-user-environment.drv'...
created 36 symlinks in user environment
</code></pre>
<p>Now you can run <code>hello</code>. Things to notice:</p>
<ul>
<li>
<p>We installed software as a user, and only for the Nix user.</p>
</li>
<li>
<p>It created a new user environment. That's a new generation of our
Nix user profile.</p>
</li>
<li>
<p>The
<a href="https://nixos.org/manual/nix/stable/command-ref/nix-env.html">nix-env</a>
tool manages environments, profiles and their generations.</p>
</li>
<li>
<p>We installed <code>hello</code> by derivation name minus the version. I repeat:
we specified the <strong>derivation name</strong> (minus the version) to install
it.</p>
</li>
</ul>
<p>We can list generations without walking through the <code>/nix</code> hierarchy:</p>
<pre><code>$ nix-env --list-generations
   1   2014-07-24 09:23:30
   2   2014-07-25 08:45:01   (current)
</code></pre>
<p>Listing installed derivations:</p>
<pre><code>$ nix-env -q
nix-2.1.3
hello-2.10
</code></pre>
<p>So, where did <code>hello</code> really get installed? <code>which hello</code> is
<code>~/.nix-profile/bin/hello</code> which points to the store. We can also list
the derivation paths with <code>nix-env -q --out-path</code>. So that's what those
derivation paths are called: the <strong>output</strong> of a build.</p>
<h2 id="path-merging"><a class="header" href="#path-merging">Path merging</a></h2>
<p>At this point you probably want to run <code>man</code> to get some documentation.
Even if you already have man system-wide outside of the Nix environment,
you can install and use it within Nix with <code>nix-env -i man-db</code>. As
usual, a new generation will be created, and <code>~/.nix-profile</code> will point
to it.</p>
<p>Let's inspect the
<a href="https://nixos.org/manual/nix/stable/package-management/profiles.html">profile</a>
a bit:</p>
<pre><code>$ ls -l ~/.nix-profile/
dr-xr-xr-x 2 nix nix 4096 Jan  1  1970 bin
lrwxrwxrwx 1 nix nix   55 Jan  1  1970 etc -&gt; /nix/store/ig31y9gfpp8pf3szdd7d4sf29zr7igbr-nix-2.1.3/etc
[...]
</code></pre>
<p>Now that's interesting. When only <code>nix-2.1.3</code> was installed, <code>bin</code> was
a symlink to <code>nix-2.1.3</code>. Now that we've actually installed some things
(<code>man</code>, <code>hello</code>), it's a real directory, not a symlink.</p>
<pre><code>$ ls -l ~/.nix-profile/bin/
[...]
man -&gt; /nix/store/83cn9ing5sc6644h50dqzzfxcs07r2jn-man-1.6g/bin/man
[...]
nix-env -&gt; /nix/store/ig31y9gfpp8pf3szdd7d4sf29zr7igbr-nix-2.1.3/bin/nix-env
[...]
hello -&gt; /nix/store/58r35bqb4f3lxbnbabq718svq9i2pda3-hello-2.10/bin/hello
[...]
</code></pre>
<p>Okay, that's clearer now. <code>nix-env</code> merged the paths from the installed
derivations. <code>which man</code> points to the Nix profile, rather than the
system <code>man</code>, because <code>~/.nix-profile/bin</code> is at the head of <code>$PATH</code>.</p>
<h2 id="rolling-back-and-switching-generation"><a class="header" href="#rolling-back-and-switching-generation">Rolling back and switching generation</a></h2>
<p>The last command installed <code>man</code>. We should be at generation 3, unless
you changed something in the middle. Let's say we want to rollback to
the old generation:</p>
<pre><code>$ nix-env --rollback
switching from generation 3 to 2
</code></pre>
<p>Now <code>nix-env -q</code> does not list <code>man</code> anymore. <code>ls -l `which man`</code>
should now be your system copy.</p>
<p>Enough with the rollback, let's go back to the most recent generation:</p>
<pre><code>$ nix-env -G 3
switching from generation 2 to 3
</code></pre>
<p>I invite you to read the manpage of <code>nix-env</code>. <code>nix-env</code> requires an
operation to perform, then there are common options for all operations,
as well as options specific to each operation.</p>
<p>You can of course also <a href="https://nixos.org/manual/nix/stable/command-ref/nix-env.html#operation---uninstall">
uninstall</a>
and
<a href="https://nixos.org/manual/nix/stable/command-ref/nix-env.html#operation---upgrade">upgrade</a>
packages.</p>
<h2 id="querying-the-store"><a class="header" href="#querying-the-store">Querying the store</a></h2>
<p>So far we learned how to query and manipulate the environment. But all
of the environment components point to the store.</p>
<p>To query and manipulate the store, there's the <code>nix-store</code> command. We
can do some interesting things, but we'll only see some queries for
now.</p>
<p>To show the direct runtime dependencies of <code>hello</code>:</p>
<pre><code>$ nix-store -q --references `which hello`
/nix/store/fg4yq8i8wd08xg3fy58l6q73cjy8hjr2-glibc-2.27
/nix/store/58r35bqb4f3lxbnbabq718svq9i2pda3-hello-2.10
</code></pre>
<p>The argument to <code>nix-store</code> can be anything as long as it points to the
Nix store. It will follow symlinks.</p>
<p>It may not make sense to you right now, but let's print reverse
dependencies of <code>hello</code>:</p>
<pre><code>$ nix-store -q --referrers `which hello`
/nix/store/58r35bqb4f3lxbnbabq718svq9i2pda3-hello-2.10
/nix/store/fhvy2550cpmjgcjcx5rzz328i0kfv3z3-env-manifest.nix
/nix/store/yzdk0xvr0b8dcwhi2nns6d75k2ha5208-env-manifest.nix
/nix/store/mp987abm20c70pl8p31ljw1r5by4xwfw-user-environment
/nix/store/ppr3qbq7fk2m2pa49i2z3i32cvfhsv7p-user-environment
</code></pre>
<p>Was it what you expected? It turns out that our environments depend upon
<code>hello</code>. Yes, that means that the environments are in the store, and
since they contain symlinks to <code>hello</code>, therefore the environment
depends upon <code>hello</code>.</p>
<p>Two environments were listed, generation 2 and generation 3, since these
are the ones that had <code>hello</code> installed in them.</p>
<p>The <code>manifest.nix</code> file contains metadata about the environment, such as
which derivations are installed. So that <code>nix-env</code> can list, upgrade or
remove them. And yet again, the current <code>manifest.nix</code> can be found at
<code>~/.nix-profile/manifest.nix</code>.</p>
<h2 id="closures"><a class="header" href="#closures">Closures</a></h2>
<p>The closures of a derivation is a list of all its dependencies,
recursively, including absolutely everything necessary to use that
derivation.</p>
<pre><code>$ nix-store -qR `which man`
[...]
</code></pre>
<p>Copying all those derivations to the Nix store of another machine makes
you able to run <code>man</code> out of the box on that other machine. That's the
base of deployment using Nix, and you can already foresee the potential
when deploying software in the cloud (hint: <code>nix-copy-closures</code> and
<code>nix-store --export</code>).</p>
<p>A nicer view of the closure:</p>
<pre><code>$ nix-store -q --tree `which man`
[...]
</code></pre>
<p>With the above command, you can find out exactly why a <em>runtime</em>
dependency, be it direct or indirect, exists for a given derivation.</p>
<p>The same applies to environments. As an exercise, run
<code>nix-store -q --tree ~/.nix-profile</code>, and see that the first children
are direct dependencies of the user environment: the installed
derivations, and the <code>manifest.nix</code>.</p>
<h2 id="dependency-resolution"><a class="header" href="#dependency-resolution">Dependency resolution</a></h2>
<p>There isn't anything like <code>apt</code> which solves a SAT problem in order to
satisfy dependencies with lower and upper bounds on versions. There's
no need for this because all the dependencies are static: if a
derivation X depends on a derivation Y, then it always depends on it. A
version of X which depended on Z would be a different derivation.</p>
<h2 id="recovering-the-hard-way"><a class="header" href="#recovering-the-hard-way">Recovering the hard way</a></h2>
<pre><code>$ nix-env -e '*'
uninstalling 'hello-2.10'
uninstalling 'nix-2.1.3'
[...]
</code></pre>
<p>Oops, that uninstalled all derivations from the environment, including
Nix. That means we can't even run <code>nix-env</code>, what now?</p>
<p>Previously we got <code>nix-env</code> from the environment. Environments are a
convenience for the user, but Nix is still there in the store!</p>
<p>First, pick one <code>nix-2.1.3</code> derivation: <code>ls /nix/store/*nix-2.1.3</code>, say
<code>/nix/store/ig31y9gfpp8pf3szdd7d4sf29zr7igbr-nix-2.1.3</code>.</p>
<p>The first option is to rollback:</p>
<pre><code>$ /nix/store/ig31y9gfpp8pf3szdd7d4sf29zr7igbr-nix-2.1.3/bin/nix-env --rollback
</code></pre>
<p>The second option is to install Nix, thus creating a new generation:</p>
<pre><code>$ /nix/store/ig31y9gfpp8pf3szdd7d4sf29zr7igbr-nix-2.1.3/bin/nix-env -i /nix/store/ig31y9gfpp8pf3szdd7d4sf29zr7igbr-nix-2.1.3/bin/nix-env 
</code></pre>
<h2 id="channels"><a class="header" href="#channels">Channels</a></h2>
<p>So where are we getting packages from? We said something about this
already in the <a href="02-install-on-your-running.html">second article</a>.
There's a list of channels from which we get packages, although usually
we use a single channel. The tool to manage channels is
<a href="https://nixos.org/manual/nix/stable/command-ref/nix-channel.html">nix-channel</a>.</p>
<pre><code>$ nix-channel --list
nixpkgs http://nixos.org/channels/nixpkgs-unstable
</code></pre>
<p>If you're using NixOS, you may not see any output from the above
command (if you're using the default), or you may see a channel whose
name begins with "nixos-" instead of "nixpkgs".</p>
<p>That's essentially the contents of <code>~/.nix-channels</code>.</p>
<div class="info">
<p>Note: <code>~/.nix-channels</code> is not a symlink to the nix store!</p>
</div>
<p>To update the channel run <code>nix-channel --update</code>. That will download the
new Nix expressions (descriptions of the packages), create a new
generation of the channels profile and unpack it under
<code>~/.nix-defexpr/channels</code>.</p>
<p>This is quite similar to <code>apt-get update</code>. (See <a href="https://nixos.wiki/wiki/Cheatsheet">this
table</a> for a rough mapping between
Ubuntu and NixOS package management.)</p>
<h2 id="conclusion-2"><a class="header" href="#conclusion-2">Conclusion</a></h2>
<p>We learned how to query the user environment and to manipulate it by
installing and uninstalling software. Upgrading software is also
straightforward, as you can read in <a href="https://nixos.org/manual/nix/stable/command-ref/nix-env.html#operation---upgrade">the
manual</a>
(<code>nix-env -u</code> will upgrade all packages in the environment).</p>
<p>Every time we change the environment, a new generation is created.
Switching between generations is easy and immediate.</p>
<p>Then we learned how to query the store. We inspected the dependencies
and reverse dependencies of store paths.</p>
<p>We saw how symlinks are used to compose paths from the Nix store, a
useful trick.</p>
<p>A quick analogy with programming languages: you have the heap with all
the objects, that corresponds to the Nix store. You have objects that
point to other objects, those correspond to derivations. This is a
suggestive metaphor, but will it be the right path?</p>
<h2 id="next-pill-2"><a class="header" href="#next-pill-2">Next pill</a></h2>
<p>...we will learn the basics of the Nix language. The Nix language is
used to describe how to build derivations, and it's the basis for
everything else, including NixOS. Therefore it's very important to
understand both the syntax and the semantics of the language.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics-of-language"><a class="header" href="#basics-of-language">The Basics of the Language</a></h1>
<p>Welcome to the fourth Nix pill. In the <a href="03-enter-environment.html">previous
article</a> we learned about Nix environments. We
installed software as a user, managed their profile, switched between
generations, and queried the Nix store. Those are the very basics of
system administration using Nix.</p>
<p>The <a href="https://nixos.org/manual/nix/stable/expressions/expression-language.html">Nix
language</a>
is used to write expressions that produce derivations. The
<a href="https://nixos.org/manual/nix/stable/command-ref/nix-build.html">nix-build</a>
tool is used to build derivations from an expression. Even as a system
administrator that wants to customize the installation, it's necessary
to master Nix. Using Nix for your jobs means you get the features we saw
in the previous articles for free.</p>
<p>The syntax of Nix is quite unfamiliar, so looking at existing examples
may lead you to think that there's a lot of magic happening. In
reality, it's mostly about writing utility functions to make things
convenient.</p>
<p>On the other hand, the same syntax is great for describing packages, so
learning the language itself will pay off when writing package
expressions.</p>
<div class="info">
Important: In Nix, everything is an expression, there are no statements. This is
common in functional languages.
</div>
<div class="info">
Important: Values in Nix are immutable.
</div>
<h2 id="value-types"><a class="header" href="#value-types">Value types</a></h2>
<p>Nix 2.0 contains a command named <code>nix repl</code> which is a simple command
line tool for playing with the Nix language. In fact, Nix is a <a href="https://nixos.org/manual/nix/stable/expressions/expression-language.html">pure,
lazy, functional
language</a>,
not only a set of tools to manage derivations. The <code>nix repl</code> syntax is
slightly different to Nix syntax when it comes to assigning variables,
but it shouldn't be confusing so long as you bear it in mind. I prefer
to start with <code>nix repl</code> before cluttering your mind with more complex
expressions.</p>
<p>Launch <code>nix repl</code>. First of all, Nix supports basic arithmetic
operations: <code>+</code>, <code>-</code>, <code>*</code> and <code>/</code>. (To exit <code>nix repl</code>, use the command
<code>:q</code>. Help is available through the <code>:?</code> command.)</p>
<pre><code>nix-repl&gt; 1+3
4

nix-repl&gt; 7-4
3

nix-repl&gt; 3*2
6
</code></pre>
<p>Attempting to perform division in Nix can lead to some surprises.</p>
<pre><code>nix-repl&gt; 6/3
/home/nix/6/3
</code></pre>
<p>What happened? Recall that Nix is not a general purpose language, it's
a domain-specific language for writing packages. Integer division isn't
actually that useful when writing package expressions. Nix parsed <code>6/3</code>
as a relative path to the current directory. To get Nix to perform
division instead, leave a space after the <code>/</code>. Alternatively, you can
use <code>builtins.div</code>.</p>
<pre><code>nix-repl&gt; 6/ 3
2

nix-repl&gt; builtins.div 6 3
2
</code></pre>
<p>Other operators are <code>||</code>, <code>&amp;&amp;</code> and <code>!</code> for booleans, and relational
operators such as <code>!=</code>, <code>==</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>. In Nix, <code>&lt;</code>, <code>&gt;</code>,
<code>&lt;=</code> and <code>&gt;=</code> are not much used. There are also other operators we will
see in the course of this series.</p>
<p>Nix has integer, floating point, string, path, boolean and null
<a href="https://nixos.org/manual/nix/stable/expressions/language-values.html">simple</a>
types. Then there are also lists, sets and functions. These types are
enough to build an operating system.</p>
<p>Nix is strongly typed, but it's not statically typed. That is, you
cannot mix strings and integers, you must first do the conversion.</p>
<p>As demonstrated above, expressions will be parsed as paths as long as
there's a slash not followed by a space. Therefore to specify the
current directory, use <code>./.</code> In addition, Nix also parses urls
specially.</p>
<p>Not all urls or paths can be parsed this way. If a syntax error occurs,
it's still possible to fallback to plain strings. Literal urls and
paths are convenient for additional safety.</p>
<h2 id="identifier"><a class="header" href="#identifier">Identifier</a></h2>
<p>There's not much to say here, except that dash (<code>-</code>) is allowed in
identifiers. That's convenient since many packages use dash in their
names. In fact:</p>
<pre><code>nix-repl&gt; a-b
error: undefined variable `a-b' at (string):1:1
nix-repl&gt; a - b
error: undefined variable `a' at (string):1:1
</code></pre>
<p>As you can see, <code>a-b</code> is parsed as identifier, not as a subtraction.</p>
<h2 id="strings"><a class="header" href="#strings">Strings</a></h2>
<p>It's important to understand the syntax for strings. When learning to
read Nix expressions, you may find dollars (<code>$</code>) ambiguous, but they are
very important . Strings are enclosed by double quotes (<code>"</code>), or two
single quotes (<code>''</code>).</p>
<pre><code>nix-repl&gt; "foo"
"foo"
nix-repl&gt; ''foo''
"foo"
</code></pre>
<p>In other languages like Python you can also use single quotes for
strings (e.g. <code>'foo'</code>), but not in Nix.</p>
<p>It's possible to
<a href="https://nixos.org/manual/nix/stable/expressions/language-values.html">interpolate</a>
whole Nix expressions inside strings with the <code>${...}</code> syntax and only
that syntax, not <code>$foo</code> or <code>{$foo}</code> or anything else.</p>
<pre><code>nix-repl&gt; foo = "strval"
nix-repl&gt; "$foo"
"$foo"
nix-repl&gt; "${foo}"
"strval"
nix-repl&gt; "${2+3}"
error: cannot coerce an integer to a string, at (string):1:2
</code></pre>
<p>Note: ignore the <code>foo = "strval"</code> assignment, special syntax in
<code>nix repl</code>.</p>
<p>As said previously, you cannot mix integers and strings. You need to
explicitly include conversions. We'll see this later: function calls
are another story.</p>
<p>Using the syntax with two single quotes is useful for writing double
quotes inside strings without needing to escape them:</p>
<pre><code>nix-repl&gt; ''test " test''
"test \" test"
nix-repl&gt; ''${foo}''
"strval"
</code></pre>
<p>Escaping <code>${...}</code> within double quoted strings is done with the
backslash. Within two single quotes, it's done with <code>''</code>:</p>
<pre><code>nix-repl&gt; "\${foo}"
"${foo}"
nix-repl&gt; ''test ''${foo} test''
"test ${foo} test"
</code></pre>
<h2 id="lists"><a class="header" href="#lists">Lists</a></h2>
<p>Lists are a sequence of expressions delimited by space (<em>not</em> comma):</p>
<pre><code>nix-repl&gt; [ 2 "foo" true (2+3) ]
[ 2 "foo" true 5 ]
</code></pre>
<p>Lists, like everything else in Nix, are immutable. Adding or removing
elements from a list is possible, but will return a new list.</p>
<h2 id="attribute-sets"><a class="header" href="#attribute-sets">Attribute sets</a></h2>
<p>An attribute set is an association between string keys and Nix values.
Keys can only be strings. When writing attribute sets you can also use
unquoted identifiers as keys.</p>
<pre><code>nix-repl&gt; s = { foo = "bar"; a-b = "baz"; "123" = "num"; }
nix-repl&gt; s
{ "123" = "num"; a-b = "baz"; foo = "bar"; }
</code></pre>
<p>For those reading Nix expressions from nixpkgs: do not confuse attribute
sets with argument sets used in functions.</p>
<p>To access elements in the attribute set:</p>
<pre><code>nix-repl&gt; s.a-b
"baz"
nix-repl&gt; s."123"
"num"
</code></pre>
<p>Yes, you can use strings to address keys which aren't valid
identifiers.</p>
<p>Inside an attribute set you cannot normally refer to elements of the
same attribute set:</p>
<pre><code>nix-repl&gt; { a = 3; b = a+4; }
error: undefined variable `a' at (string):1:10
</code></pre>
<p>To do so, use <a href="https://nixos.org/manual/nix/stable/expressions/language-constructs.html#recursive-sets">recursive attribute
sets</a>:</p>
<pre><code>nix-repl&gt; rec { a = 3; b = a+4; }
{ a = 3; b = 7; }
</code></pre>
<p>This is very convenient when defining packages, which tend to be
recursive attribute sets.</p>
<h2 id="if-expressions"><a class="header" href="#if-expressions">If expressions</a></h2>
<p>These are expressions, not statements.</p>
<pre><code>nix-repl&gt; a = 3
nix-repl&gt; b = 4
nix-repl&gt; if a &gt; b then "yes" else "no"
"no"
</code></pre>
<p>You can't have only the <code>then</code> branch, you must specify also the <code>else</code>
branch, because an expression must have a value in all cases.</p>
<h2 id="let-expressions"><a class="header" href="#let-expressions">Let expressions</a></h2>
<p>This kind of expression is used to define local variables for inner
expressions.</p>
<pre><code>nix-repl&gt; let a = "foo"; in a
"foo"
</code></pre>
<p>The syntax is: first assign variables, then <code>in</code>, then an expression
which can use the defined variables. The value of the whole <code>let</code>
expression will be the value of the expression after the <code>in</code>.</p>
<pre><code>nix-repl&gt; let a = 3; b = 4; in a + b
7
</code></pre>
<p>Let's write two <code>let</code> expressions, one inside the other:</p>
<pre><code>nix-repl&gt; let a = 3; in let b = 4; in a + b
7
</code></pre>
<p>With <code>let</code> you cannot assign twice to the same variable. However, you
can shadow outer variables:</p>
<pre><code>nix-repl&gt; let a = 3; a = 8; in a
error: attribute `a' at (string):1:12 already defined at (string):1:5
nix-repl&gt; let a = 3; in let a = 8; in a
8
</code></pre>
<p>You cannot refer to variables in a <code>let</code> expression outside of it:</p>
<pre><code>nix-repl&gt; let a = (let c = 3; in c); in c
error: undefined variable `c' at (string):1:31
</code></pre>
<p>You can refer to variables in the <code>let</code> expression when assigning
variables, like with recursive attribute sets:</p>
<pre><code>nix-repl&gt; let a = 4; b = a + 5; in b
9
</code></pre>
<p>So beware when you want to refer to a variable from the outer scope, but
it's also defined in the current let expression. The same applies to
recursive attribute sets.</p>
<h2 id="with-expression"><a class="header" href="#with-expression">With expression</a></h2>
<p>This kind of expression is something you rarely see in other languages.
You can think of it like a more granular version of <code>using</code> from C++, or
<code>from module import *</code> from Python. You decide per-expression when to
include symbols into the scope.</p>
<pre><code>nix-repl&gt; longName = { a = 3; b = 4; }
nix-repl&gt; longName.a + longName.b
7
nix-repl&gt; with longName; a + b
7
</code></pre>
<p>That's it, it takes an attribute set and includes symbols from it in
the scope of the inner expression. Of course, only valid identifiers
from the keys of the set will be included. If a symbol exists in the
outer scope and would also be introduced by the <code>with</code>, it will <em>not</em> be
shadowed. You can however still refer to the attribute set:</p>
<pre><code>nix-repl&gt; let a = 10; in with longName; a + b
14
nix-repl&gt; let a = 10; in with longName; longName.a + b
7
</code></pre>
<h2 id="laziness"><a class="header" href="#laziness">Laziness</a></h2>
<p>Nix evaluates expressions only when needed. This is a great feature when
working with packages.</p>
<pre><code>nix-repl&gt; let a = builtins.div 4 0; b = 6; in b
6
</code></pre>
<p>Since <code>a</code> is not needed, there's no error about division by zero,
because the expression is not in need to be evaluated. That's why we
can have all the packages defined on demand, yet have access to specific
packages very quickly.</p>
<h2 id="next-pill-3"><a class="header" href="#next-pill-3">Next pill</a></h2>
<p>...we will talk about functions and imports. In this pill I've tried
to avoid function calls as much as possible, otherwise the post would
have been too long.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-and-imports"><a class="header" href="#functions-and-imports">Functions and Imports</a></h1>
<p>Welcome to the fifth Nix pill. In the previous <a href="04-basics-of-language.html">fourth
pill</a> we touched the Nix language for a moment. We
introduced basic types and values of the Nix language, and basic
expressions such as <code>if</code>, <code>with</code> and <code>let</code>. I invite you to re-read
about these expressions and play with them in the repl.</p>
<p>Functions help to build reusable components in a big repository like
<a href="https://github.com/NixOS/nixpkgs/">nixpkgs</a>. The Nix manual has a
<a href="https://nixos.org/manual/nix/stable/expressions/language-constructs.html#functions">great explanation of
functions</a>.
Let's go: pill on one hand, Nix manual on the other hand.</p>
<p>I remind you how to enter the Nix environment:
<code>source ~/.nix-profile/etc/profile.d/nix.sh</code></p>
<h2 id="nameless-and-single-parameter"><a class="header" href="#nameless-and-single-parameter">Nameless and single parameter</a></h2>
<p>Functions are anonymous (lambdas), and only have a single parameter. The
syntax is extremely simple. Type the parameter name, then "<code>:</code>", then
the body of the function.</p>
<pre><code>nix-repl&gt; x: x*2
«lambda»
</code></pre>
<p>So here we defined a function that takes a parameter <code>x</code>, and returns
<code>x*2</code>. The problem is that we cannot use it in any way, because it's
unnamed... joke!</p>
<p>We can store functions in variables.</p>
<pre><code>nix-repl&gt; double = x: x*2
nix-repl&gt; double
«lambda»
nix-repl&gt; double 3
6
</code></pre>
<p>As usual, please ignore the special syntax for assignments inside
<code>nix repl</code>. So, we defined a function <code>x: x*2</code> that takes one parameter
<code>x</code>, and returns <code>x*2</code>. This function is then assigned to the variable
<code>double</code>. Finally we did our first function call: <code>double 3</code>.</p>
<p>Big note: it's not like many other programming languages
where you write <code>double(3)</code>. It really is <code>double 3</code>.</p>
<p>In summary: to call a function, name the variable, then space, then the
argument. Nothing else to say, it's as easy as that.</p>
<h2 id="more-than-one-parameter"><a class="header" href="#more-than-one-parameter">More than one parameter</a></h2>
<p>How do we create a function that accepts more than one parameter? For
people not used to functional programming, this may take a while to
grasp. Let's do it step by step.</p>
<pre><code>nix-repl&gt; mul = a: (b: a*b)
nix-repl&gt; mul
«lambda»
nix-repl&gt; mul 3
«lambda»
nix-repl&gt; (mul 3) 4
12
</code></pre>
<p>We defined a function that takes the parameter <code>a</code>, the body returns
another function. This other function takes a parameter <code>b</code> and returns
<code>a*b</code>. Therefore, calling <code>mul 3</code> returns this kind of function:
<code>b: 3*b</code>. In turn, we call the returned function with <code>4</code>, and get the
expected result.</p>
<p>You don't have to use parentheses at all, Nix has sane priorities when
parsing the code:</p>
<pre><code>nix-repl&gt; mul = a: b: a*b
nix-repl&gt; mul
«lambda»
nix-repl&gt; mul 3
«lambda»
nix-repl&gt; mul 3 4
12
nix-repl&gt; mul (6+7) (8+9)
221
</code></pre>
<p>Much more readable, you don't even notice that functions only receive
one argument. Since the argument is separated by a space, to pass more
complex expressions you need parentheses. In other common languages you
would write <code>mul(6+7, 8+9)</code>.</p>
<p>Given that functions have only one parameter, it is straightforward to
use <strong>partial application</strong>:</p>
<pre><code>nix-repl&gt; foo = mul 3
nix-repl&gt; foo 4
12
nix-repl&gt; foo 5
15
</code></pre>
<p>We stored the function returned by <code>mul 3</code> into a variable foo, then
reused it.</p>
<h2 id="argument-set"><a class="header" href="#argument-set">Argument set</a></h2>
<p>Now this is a very cool feature of Nix. It is possible to pattern match
over a set in the parameter. We write an alternative version of
<code>mul = a: b: a*b</code> first by using a set as argument, then using pattern
matching.</p>
<pre><code>nix-repl&gt; mul = s: s.a*s.b
nix-repl&gt; mul { a = 3; b = 4; }
12
nix-repl&gt; mul = { a, b }: a*b
nix-repl&gt; mul { a = 3; b = 4; }
12
</code></pre>
<p>In the first case we defined a function that accepts a single parameter.
We then access attributes <code>a</code> and <code>b</code> from the given set. Note how the
parentheses-less syntax for function calls is very elegant in this case,
instead of doing <code>mul({ a=3; b=4; })</code> in other languages.</p>
<p>In the second case we defined an argument set. It's like defining a
set, except without values. We require that the passed set contains the
keys <code>a</code> and <code>b</code>. Then we can use those <code>a</code> and <code>b</code> in the function body
directly.</p>
<pre><code>nix-repl&gt; mul = { a, b }: a*b
nix-repl&gt; mul { a = 3; b = 4; c = 6; }
error: anonymous function at (string):1:2 called with unexpected argument `c', at (string):1:1
nix-repl&gt; mul { a = 3; }
error: anonymous function at (string):1:2 called without required argument `b', at (string):1:1
</code></pre>
<p>Only a set with exactly the attributes required by the function is
accepted, nothing more, nothing less.</p>
<h2 id="default-and-variadic-attributes"><a class="header" href="#default-and-variadic-attributes">Default and variadic attributes</a></h2>
<p>It is possible to specify <strong>default values</strong> of attributes in the
argument set:</p>
<pre><code>nix-repl&gt; mul = { a, b ? 2 }: a*b
nix-repl&gt; mul { a = 3; }
6
nix-repl&gt; mul { a = 3; b = 4; }
12
</code></pre>
<p>Also you can allow passing more attributes (<strong>variadic</strong>) than the
expected ones:</p>
<pre><code>nix-repl&gt; mul = { a, b, ... }: a*b
nix-repl&gt; mul { a = 3; b = 4; c = 2; }
</code></pre>
<p>However, in the function body you cannot access the "c" attribute. The
solution is to give a name to the given set with the <strong>@-pattern</strong>:</p>
<pre><code>nix-repl&gt; mul = s@{ a, b, ... }: a*b*s.c
nix-repl&gt; mul { a = 3; b = 4; c = 2; }
24
</code></pre>
<p>That's it, you give a name to the whole parameter with name@ before the
set pattern.</p>
<p>Advantages of using argument sets:</p>
<ul>
<li>
<p>Named unordered arguments: you don't have to remember the order of
the arguments.</p>
</li>
<li>
<p>You can pass sets, that adds a whole new layer of flexibility and
convenience.</p>
</li>
</ul>
<p>Disadvantages:</p>
<ul>
<li>Partial application does not work with argument sets. You have to
specify the whole attribute set, not part of it.</li>
</ul>
<p>You may find similarities with <a href="https://docs.python.org/3/faq/programming.html#how-can-i-pass-optional-or-keyword-parameters-from-one-function-to-another">Python
**kwargs</a>.</p>
<h2 id="imports"><a class="header" href="#imports">Imports</a></h2>
<p>The <code>import</code> function is built-in and provides a way to parse a <code>.nix</code>
file. The natural approach is to define each component in a <code>.nix</code> file,
then compose by importing these files.</p>
<p>Let's start with the bare metal.</p>
<p><code>a.nix</code>:</p>
<pre><code>3
</code></pre>
<p><code>b.nix</code>:</p>
<pre><code>4
</code></pre>
<p><code>mul.nix</code>:</p>
<pre><code>a: b: a*b

nix-repl&gt; a = import ./a.nix
nix-repl&gt; b = import ./b.nix
nix-repl&gt; mul = import ./mul.nix
nix-repl&gt; mul a b
12
</code></pre>
<p>Yes it's really that simple. You import a file, and it gets parsed as
an expression. Note that the scope of the imported file does not inherit
the scope of the importer.</p>
<p><code>test.nix</code>:</p>
<pre><code>x

nix-repl&gt; let x = 5; in import ./test.nix
error: undefined variable `x' at /home/lethal/test.nix:1:1
</code></pre>
<p>So how do we pass information to the module? Use functions, like we did
with <code>mul.nix</code>. A more complex example:</p>
<p><code>test.nix</code>:</p>
<pre><code>{ a, b ? 3, trueMsg ? "yes", falseMsg ? "no" }:
if a &gt; b
  then builtins.trace trueMsg true
  else builtins.trace falseMsg false

nix-repl&gt; import ./test.nix { a = 5; trueMsg = "ok"; }
trace: ok
true
</code></pre>
<p>Explaining:</p>
<ul>
<li>
<p>In <code>test.nix</code> we return a function. It accepts a set, with default
attributes <code>b</code>, <code>trueMsg</code> and <code>falseMsg</code>.</p>
</li>
<li>
<p><code>builtins.trace</code> is a <a href="https://nixos.org/manual/nix/stable/expressions/builtins.html">built-in
function</a>
that takes two arguments. The first is the message to display, the
second is the value to return. It's usually used for debugging
purposes.</p>
</li>
<li>
<p>Then we import <code>test.nix</code>, and call the function with that set.</p>
</li>
</ul>
<p>So when is the message shown? Only when it needs to be evaluated.</p>
<h2 id="next-pill-4"><a class="header" href="#next-pill-4">Next pill</a></h2>
<p>...we will finally write our first derivation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="our-first-derivation"><a class="header" href="#our-first-derivation">Our First Derivation</a></h1>
<p>Welcome to the sixth Nix pill. In the previous <a href="05-functions-and-imports.html">fifth
pill</a> we introduced functions and imports.
Functions and imports are very simple concepts that allow for building
complex abstractions and composition of modules to build a flexible Nix
system.</p>
<p>In this post we finally arrived to writing a derivation. Derivations are
the building blocks of a Nix system, from a file system view point. The
Nix language is used to describe such derivations.</p>
<p>I remind you how to enter the Nix environment:
<code>source ~/.nix-profile/etc/profile.d/nix.sh</code></p>
<h2 id="the-derivation-function"><a class="header" href="#the-derivation-function">The derivation function</a></h2>
<p>The <a href="https://nixos.org/manual/nix/stable/expressions/derivations.html">derivation built-in
function</a>
is used to create derivations. I invite you to read the link in the Nix
manual about the derivation built-in. A derivation from a Nix language
view point is simply a set, with some attributes. Therefore you can pass
the derivation around with variables like anything else.</p>
<p>That's where the real power comes in.</p>
<p>The <code>derivation</code> function receives a set as its first argument. This set
requires at least the following three attributes:</p>
<ul>
<li>
<p>name: the name of the derivation. In the nix store the format is
hash-name, that's the name.</p>
</li>
<li>
<p>system: is the name of the system in which the derivation can be
built. For example, x86_64-linux.</p>
</li>
<li>
<p>builder: is the binary program that builds the derivation.</p>
</li>
</ul>
<p>First of all, what's the name of our system as seen by nix?</p>
<pre><code>nix-repl&gt; builtins.currentSystem
"x86_64-linux"
</code></pre>
<p>Let's try to fake the name of the system:</p>
<pre><code>nix-repl&gt; d = derivation { name = "myname"; builder = "mybuilder"; system = "mysystem"; }
nix-repl&gt; d
«derivation /nix/store/z3hhlxbckx4g3n9sw91nnvlkjvyw754p-myname.drv»
</code></pre>
<p>Oh oh, what's that? Did it build the derivation? No it didn't, but it
<strong>did create the .drv file</strong>. <code>nix repl</code> does not build derivations
unless you tell it to do so.</p>
<h2 id="digression-about-drv-files"><a class="header" href="#digression-about-drv-files">Digression about .drv files</a></h2>
<p>What's that <code>.drv</code> file? It is the specification of how to build the
derivation, without all the Nix language fuzz.</p>
<p>Before continuing, some analogies with the C language:</p>
<ul>
<li>
<p><code>.nix</code> files are like <code>.c</code> files.</p>
</li>
<li>
<p><code>.drv</code> files are intermediate files like <code>.o</code> files. The <code>.drv</code>
describes how to build a derivation; it's the bare minimum
information.</p>
</li>
<li>
<p>out paths are then the product of the build.</p>
</li>
</ul>
<p>Both drv paths and out paths are stored in the nix store as you can see.</p>
<p>What's in that <code>.drv</code> file? You can read it, but it's better to pretty
print it:</p>
<div class="info">
Note: If your version of nix doesn't have `nix derivation show`, use
`nix show-derivation` instead.
</div>
<pre><code>$ nix derivation show /nix/store/z3hhlxbckx4g3n9sw91nnvlkjvyw754p-myname.drv
{
  "/nix/store/z3hhlxbckx4g3n9sw91nnvlkjvyw754p-myname.drv": {
    "outputs": {
      "out": {
        "path": "/nix/store/40s0qmrfb45vlh6610rk29ym318dswdr-myname"
      }
    },
    "inputSrcs": [],
    "inputDrvs": {},
    "platform": "mysystem",
    "builder": "mybuilder",
    "args": [],
    "env": {
      "builder": "mybuilder",
      "name": "myname",
      "out": "/nix/store/40s0qmrfb45vlh6610rk29ym318dswdr-myname",
      "system": "mysystem"
    }
  }
}
</code></pre>
<p>Ok, we can see there's an out path, but it does not exist yet. We never
told Nix to build it, but we know beforehand where the build output will
be. Why?</p>
<p>Think, if Nix ever built the derivation just because we accessed it in
Nix, we would have to wait a long time if it was, say, Firefox. That's
why Nix let us know the path beforehand and kept evaluating the Nix
expressions, but it's still empty because no build was ever made.</p>
<p>Important: the hash of the out path is based solely on the
input derivations in the current version of Nix, not on the contents of
the build product. It's possible however to have
<a href="https://en.wikipedia.org/wiki/Content-addressable_storage">content-addressable</a>
derivations for e.g. tarballs as we'll see later on.</p>
<p>Many things are empty in that <code>.drv</code>, however I'll write a summary of
the <a href="http://nixos.org/~eelco/pubs/phd-thesis.pdf">.drv format</a> for you:</p>
<ol>
<li>
<p>The output paths (there can be multiple ones). By default nix
creates one out path called "out".</p>
</li>
<li>
<p>The list of input derivations. It's empty because we are not
referring to any other derivation. Otherwise, there would be a list
of other .drv files.</p>
</li>
<li>
<p>The system and the builder executable (yes, it's a fake one).</p>
</li>
<li>
<p>Then a list of environment variables passed to the builder.</p>
</li>
</ol>
<p>That's it, the minimum necessary information to build our derivation.</p>
<p>Important note: the environment variables passed to the
builder are just those you see in the .drv plus some other Nix related
configuration (number of cores, temp dir, ...). The builder will not
inherit any variable from your running shell, otherwise builds would
suffer from
<a href="https://wiki.debian.org/ReproducibleBuilds">non-determinism</a>.</p>
<p>Back to our fake derivation.</p>
<p>Let's build our really fake derivation:</p>
<pre><code>nix-repl&gt; d = derivation { name = "myname"; builder = "mybuilder"; system = "mysystem"; }
nix-repl&gt; :b d
[...]
these derivations will be built:
  /nix/store/z3hhlxbckx4g3n9sw91nnvlkjvyw754p-myname.drv
building path(s) `/nix/store/40s0qmrfb45vlh6610rk29ym318dswdr-myname'
error: a `mysystem' is required to build `/nix/store/z3hhlxbckx4g3n9sw91nnvlkjvyw754p-myname.drv', but I am a `x86_64-linux'
</code></pre>
<p>The <code>:b</code> is a <code>nix repl</code> specific command to build a derivation. You can
see more commands with <code>:?</code> . So in the output you can see that it takes
the <code>.drv</code> as information on how to build the derivation. Then it says
it's trying to produce our out path. Finally the error we were waiting
for: that derivation can't be built on our system.</p>
<p>We're doing the build inside <code>nix repl</code>, but what if we don't want to
use <code>nix repl</code>? You can <strong>realise</strong> a <code>.drv</code> with:</p>
<pre><code>$ nix-store -r /nix/store/z3hhlxbckx4g3n9sw91nnvlkjvyw754p-myname.drv
</code></pre>
<p>You will get the same output as before.</p>
<p>Let's fix the system attribute:</p>
<pre><code>nix-repl&gt; d = derivation { name = "myname"; builder = "mybuilder"; system = builtins.currentSystem; }
nix-repl&gt; :b d
[...]
build error: invalid file name `mybuilder'
</code></pre>
<p>A step forward: of course, that <code>mybuilder</code> executable does not really
exist. Stop for a moment.</p>
<h2 id="whats-in-a-derivation-set"><a class="header" href="#whats-in-a-derivation-set">What's in a derivation set</a></h2>
<p>It is useful to start by inspecting the return value from the derivation
function. In this case, the returned value is a plain set:</p>
<pre><code>nix-repl&gt; d = derivation { name = "myname"; builder = "mybuilder"; system = "mysystem"; }
nix-repl&gt; builtins.isAttrs d
true
nix-repl&gt; builtins.attrNames d
[ "all" "builder" "drvAttrs" "drvPath" "name" "out" "outPath" "outputName" "system" "type" ]
</code></pre>
<p>You can guess what <code>builtins.isAttrs</code> does; it returns true if the
argument is a set. While <code>builtins.attrNames</code> returns a list of keys of
the given set. Some kind of reflection, you might say.</p>
<p>Start from drvAttrs:</p>
<pre><code>nix-repl&gt; d.drvAttrs
{ builder = "mybuilder"; name = "myname"; system = "mysystem"; }
</code></pre>
<p>That's basically the input we gave to the derivation function. Also the
<code>d.name</code>, <code>d.system</code> and <code>d.builder</code> attributes are exactly the ones we
gave as input.</p>
<pre><code>nix-repl&gt; (d == d.out)
true
</code></pre>
<p>So out is just the derivation itself, it seems weird but the reason is
that we only have one output from the derivation. That's also the
reason why <code>d.all</code> is a singleton. We'll see multiple outputs later.</p>
<p>The <code>d.drvPath</code> is the path of the <code>.drv</code> file:
<code>/nix/store/z3hhlxbckx4g3n9sw91nnvlkjvyw754p-myname.drv</code>.</p>
<p>Something interesting is the <code>type</code> attribute. It's <code>"derivation"</code>. Nix
does add a little of magic to sets with type derivation, but not that
much. To help you understand, you can create yourself a set with that
type, it's a simple set:</p>
<pre><code>nix-repl&gt; { type = "derivation"; }
«derivation ???»
</code></pre>
<p>Of course it has no other information, so Nix doesn't know what to say
:-) But you get it, the <code>type = "derivation"</code> is just a convention for
Nix and for us to understand the set is a derivation.</p>
<p>When writing packages, we are interested in the outputs. The other
metadata is needed for Nix to know how to create the drv path and the
out path.</p>
<p>The <code>outPath</code> attribute is the build path in the nix store:
<code>/nix/store/40s0qmrfb45vlh6610rk29ym318dswdr-myname</code>.</p>
<h2 id="referring-to-other-derivations"><a class="header" href="#referring-to-other-derivations">Referring to other derivations</a></h2>
<p>Just like dependencies in other package managers, how do we refer to
other packages? How do we refer to other derivations in terms of files
on the disk? We use the <code>outPath</code>. The <code>outPath</code> describes the location
of the files of that derivation. To make it more convenient, Nix is able
to do a conversion from a derivation set to a string.</p>
<pre><code>nix-repl&gt; d.outPath
"/nix/store/40s0qmrfb45vlh6610rk29ym318dswdr-myname"
nix-repl&gt; builtins.toString d
"/nix/store/40s0qmrfb45vlh6610rk29ym318dswdr-myname"
</code></pre>
<p>Nix does the "set to string conversion" as long as there is the
<code>outPath</code> attribute (much like a toString method in other languages):</p>
<pre><code>nix-repl&gt; builtins.toString { outPath = "foo"; }
"foo"
nix-repl&gt; builtins.toString { a = "b"; }
error: cannot coerce a set to a string, at (string):1:1
</code></pre>
<p>Say we want to use binaries from coreutils (ignore the nixpkgs etc.):</p>
<pre><code>nix-repl&gt; :l &lt;nixpkgs&gt;
Added 3950 variables.
nix-repl&gt; coreutils
«derivation /nix/store/1zcs1y4n27lqs0gw4v038i303pb89rw6-coreutils-8.21.drv»
nix-repl&gt; builtins.toString coreutils
"/nix/store/8w4cbiy7wqvaqsnsnb3zvabq1cp2zhyz-coreutils-8.21"
</code></pre>
<p>Apart from the nixpkgs stuff, just think we added to the scope a series
of variables. One of them is coreutils. It is the derivation of the
coreutils package you all know of from other Linux distributions. It
contains basic binaries for GNU/Linux systems (you may have multiple
derivations of coreutils in the nix store, no worries):</p>
<pre><code>$ ls /nix/store/*coreutils*/bin
[...]
</code></pre>
<p>I remind you, inside strings it's possible to interpolate Nix
expressions with <code>${...}</code>:</p>
<pre><code>nix-repl&gt; "${d}"
"/nix/store/40s0qmrfb45vlh6610rk29ym318dswdr-myname"
nix-repl&gt; "${coreutils}"
"/nix/store/8w4cbiy7wqvaqsnsnb3zvabq1cp2zhyz-coreutils-8.21"
</code></pre>
<p>That's very convenient, because then we could refer to e.g. the
bin/true binary like this:</p>
<pre><code>nix-repl&gt; "${coreutils}/bin/true"
"/nix/store/8w4cbiy7wqvaqsnsnb3zvabq1cp2zhyz-coreutils-8.21/bin/true"
</code></pre>
<h2 id="an-almost-working-derivation"><a class="header" href="#an-almost-working-derivation">An almost working derivation</a></h2>
<p>In the previous attempt we used a fake builder, <code>mybuilder</code> which
obviously does not exist. But we can use for example bin/true, which
always exits with 0 (success).</p>
<pre><code>nix-repl&gt; :l &lt;nixpkgs&gt;
nix-repl&gt; d = derivation { name = "myname"; builder = "${coreutils}/bin/true"; system = builtins.currentSystem; }
nix-repl&gt; :b d
[...]
builder for `/nix/store/qyfrcd53wmc0v22ymhhd5r6sz5xmdc8a-myname.drv' failed to produce output path `/nix/store/ly2k1vswbfmswr33hw0kf0ccilrpisnk-myname'
</code></pre>
<p>Another step forward, it executed the builder (bin/true), but the
builder did not create the out path of course, it just exited with 0.</p>
<p>Obvious note: every time we change the derivation, a new
hash is created.</p>
<p>Let's examine the new <code>.drv</code> now that we referred to another
derivation:</p>
<pre><code>$ nix derivation show /nix/store/qyfrcd53wmc0v22ymhhd5r6sz5xmdc8a-myname.drv
{
  "/nix/store/qyfrcd53wmc0v22ymhhd5r6sz5xmdc8a-myname.drv": {
    "outputs": {
      "out": {
        "path": "/nix/store/ly2k1vswbfmswr33hw0kf0ccilrpisnk-myname"
      }
    },
    "inputSrcs": [],
    "inputDrvs": {
      "/nix/store/hixdnzz2wp75x1jy65cysq06yl74vx7q-coreutils-8.29.drv": [
        "out"
      ]
    },
    "platform": "x86_64-linux",
    "builder": "/nix/store/qrxs7sabhqcr3j9ai0j0cp58zfnny0jz-coreutils-8.29/bin/true",
    "args": [],
    "env": {
      "builder": "/nix/store/qrxs7sabhqcr3j9ai0j0cp58zfnny0jz-coreutils-8.29/bin/true",
      "name": "myname",
      "out": "/nix/store/ly2k1vswbfmswr33hw0kf0ccilrpisnk-myname",
      "system": "x86_64-linux"
    }
  }
}
</code></pre>
<p>Aha! Nix added a dependency to our myname.drv, it's the coreutils.drv.
Before doing our build, Nix should build the coreutils.drv. But since
coreutils is already in our nix store, no build is needed, it's already
there with out path
<code>/nix/store/qrxs7sabhqcr3j9ai0j0cp58zfnny0jz-coreutils-8.29</code>.</p>
<h2 id="when-is-the-derivation-built"><a class="header" href="#when-is-the-derivation-built">When is the derivation built</a></h2>
<p>Nix does not build derivations <strong>during evaluation</strong> of Nix expressions.
In fact, that's why we have to do ":b drv" in <code>nix repl</code>, or use
nix-store -r in the first place.</p>
<p>An important separation is made in Nix:</p>
<ul>
<li>
<p><strong>Instantiate/Evaluation time</strong>: the Nix expression is parsed,
interpreted and finally returns a derivation set. During evaluation,
you can refer to other derivations because Nix will create .drv
files and we will know out paths beforehand. This is achieved with
<a href="https://nixos.org/manual/nix/stable/command-ref/nix-instantiate.html">nix-instantiate</a>.</p>
</li>
<li>
<p><strong>Realise/Build time</strong>: the .drv from the derivation set is built,
first building .drv inputs (build dependencies). This is achieved
with <a href="https://nixos.org/manual/nix/stable/command-ref/nix-store.html#operation---realise">nix-store
-r</a>.</p>
</li>
</ul>
<p>Think of it as of compile time and link time like with C/C++ projects.
You first compile all source files to object files. Then link object
files in a single executable.</p>
<p>In Nix, first the Nix expression (usually in a .nix file) is compiled to
.drv, then each .drv is built and the product is installed in the
relative out paths.</p>
<h2 id="conclusion-3"><a class="header" href="#conclusion-3">Conclusion</a></h2>
<p>Is it that complicated to create a package for Nix? No, it's not.</p>
<p>We're walking through the fundamentals of Nix derivations, to
understand how they work, how they are represented. Packaging in Nix is
certainly easier than that, but we're not there yet in this post. More
Nix pills are needed.</p>
<p>With the derivation function we provide a set of information on how to
build a package, and we get back the information about where the package
was built. Nix converts a set to a string when there's an <code>outPath</code>;
that's very convenient. With that, it's easy to refer to other
derivations.</p>
<p>When Nix builds a derivation, it first creates a .drv file from a
derivation expression, and uses it to build the output. It does so
recursively for all the dependencies (inputs). It "executes" the .drv
files like a machine. Not much magic after all.</p>
<h2 id="next-pill-5"><a class="header" href="#next-pill-5">Next pill</a></h2>
<p>...we will finally write our first <strong>working</strong> derivation. Yes, this
post is about "our first derivation", but I never said it was a
working one ;)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-derivation"><a class="header" href="#working-derivation">Working Derivation</a></h1>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>Welcome to the seventh nix pill. In the previous <a href="06-our-first-derivation.html">sixth
pill</a> we introduced the notion of derivation in
the Nix language --- how to define a raw derivation and how to (try to)
build it.</p>
<p>In this post we continue along the path, by creating a derivation that
actually builds something. Then, we try to package a real program: we
compile a simple C file and create a derivation out of it, given a
blessed toolchain.</p>
<p>I remind you how to enter the Nix environment:
<code>source ~/.nix-profile/etc/profile.d/nix.sh</code></p>
<h2 id="using-a-script-as-a-builder"><a class="header" href="#using-a-script-as-a-builder">Using a script as a builder</a></h2>
<p>What's the easiest way to run a sequence of commands for building
something? A bash script. We write a custom bash script, and we want it
to be our builder. Given a <code>builder.sh</code>, we want the derivation to run
<code>bash builder.sh</code>.</p>
<p>We don't use hash bangs in <code>builder.sh</code>, because at the time we are
writing it we do not know the path to bash in the nix store. Yes, even
bash is in the nix store, everything is there.</p>
<p>We don't even use /usr/bin/env, because then we lose the cool stateless
property of Nix. Not to mention that <code>PATH</code> gets cleared when building,
so it wouldn't find bash anyway.</p>
<p>In summary, we want the builder to be bash, and pass it an argument,
<code>builder.sh</code>. Turns out the <code>derivation</code> function accepts an optional
<code>args</code> attribute which is used to pass arguments to the builder
executable.</p>
<p>First of all, let's write our <code>builder.sh</code> in the current directory:</p>
<pre><code>declare -xp
echo foo &gt; $out
</code></pre>
<p>The command <code>declare -xp</code> lists exported variables (<code>declare</code> is a
builtin bash function). As we covered in the previous pill, Nix computes
the output path of the derivation. The resulting <code>.drv</code> file contains a
list of environment variables passed to the builder. One of these is
<code>$out</code>.</p>
<p>What we have to do is create something in the path <code>$out</code>, be it a file
or a directory. In this case we are creating a file.</p>
<p>In addition, we print out the environment variables during the build
process. We cannot use env for this, because env is part of coreutils
and we don't have a dependency to it yet. We only have bash for now.</p>
<p>Like for coreutils in the previous pill, we get a blessed bash for free
from our magic nixpkgs stuff:</p>
<pre><code>nix-repl&gt; :l &lt;nixpkgs&gt;
Added 3950 variables.
nix-repl&gt; "${bash}"
"/nix/store/ihmkc7z2wqk3bbipfnlh0yjrlfkkgnv6-bash-4.2-p45"
</code></pre>
<p>So with the usual trick, we can refer to bin/bash and create
our derivation:</p>
<pre><code>nix-repl&gt; d = derivation { name = "foo"; builder = "${bash}/bin/bash"; args = [ ./builder.sh ]; system = builtins.currentSystem; }
nix-repl&gt; :b d
[1 built, 0.0 MiB DL]

this derivation produced the following outputs:
  out -&gt; /nix/store/gczb4qrag22harvv693wwnflqy7lx5pb-foo
</code></pre>
<p>We did it! The contents of
<code>/nix/store/w024zci0x1hh1wj6gjq0jagkc1sgrf5r-foo</code> is really foo. We've
built our first derivation.</p>
<p>Note that we used <code>./builder.sh</code> and not <code>"./builder.sh"</code>. This way, it
is parsed as a path, and Nix performs some magic which we will cover
later. Try using the string version and you will find that it cannot
find <code>builder.sh</code>. This is because it tries to find it relative to the
temporary build directory.</p>
<h2 id="the-builder-environment"><a class="header" href="#the-builder-environment">The builder environment</a></h2>
<p>We can use <code>nix-store --read-log</code> to see the logs our builder produced:</p>
<pre><code>$ nix-store --read-log /nix/store/gczb4qrag22harvv693wwnflqy7lx5pb-foo
declare -x HOME="/homeless-shelter"
declare -x NIX_BUILD_CORES="4"
declare -x NIX_BUILD_TOP="/tmp/nix-build-foo.drv-0"
declare -x NIX_LOG_FD="2"
declare -x NIX_STORE="/nix/store"
declare -x OLDPWD
declare -x PATH="/path-not-set"
declare -x PWD="/tmp/nix-build-foo.drv-0"
declare -x SHLVL="1"
declare -x TEMP="/tmp/nix-build-foo.drv-0"
declare -x TEMPDIR="/tmp/nix-build-foo.drv-0"
declare -x TMP="/tmp/nix-build-foo.drv-0"
declare -x TMPDIR="/tmp/nix-build-foo.drv-0"
declare -x builder="/nix/store/q1g0rl8zfmz7r371fp5p42p4acmv297d-bash-4.4-p19/bin/bash"
declare -x name="foo"
declare -x out="/nix/store/gczb4qrag22harvv693wwnflqy7lx5pb-foo"
declare -x system="x86_64-linux"
</code></pre>
<p>Let's inspect those environment variables printed during the build
process.</p>
<ul>
<li>
<p><code>$HOME</code> is not your home directory, and <code>/homeless-shelter</code> doesn't
exist at all. We force packages not to depend on <code>$HOME</code> during the
build process.</p>
</li>
<li>
<p><code>$PATH</code> plays the same game as <code>$HOME</code></p>
</li>
<li>
<p><code>$NIX_BUILD_CORES</code> and <code>$NIX_STORE</code> are <a href="https://nixos.org/manual/nix/stable/command-ref/conf-file.html">nix configuration
options</a></p>
</li>
<li>
<p><code>$PWD</code> and <code>$TMP</code> clearly show that nix created a temporary build
directory</p>
</li>
<li>
<p>Then <code>$builder</code>, <code>$name</code>, <code>$out</code>, and <code>$system</code> are variables set
due to the .drv file's contents.</p>
</li>
</ul>
<p>And that's how we were able to use <code>$out</code> in our derivation and put
stuff in it. It's like Nix reserved a slot in the nix store for us, and
we must fill it.</p>
<p>In terms of autotools, <code>$out</code> will be the <code>--prefix</code> path. Yes, not the
make <code>DESTDIR</code>, but the <code>--prefix</code>. That's the essence of stateless
packaging. You don't install the package in a global common path under
<code>/</code>, you install it in a local isolated path under your nix store slot.</p>
<h2 id="the-drv-contents"><a class="header" href="#the-drv-contents">The .drv contents</a></h2>
<p>We added something else to the derivation this time: the args attribute.
Let's see how this changed the .drv compared to the previous pill:</p>
<pre><code>$ nix derivation show /nix/store/i76pr1cz0za3i9r6xq518bqqvd2raspw-foo.drv
{
  "/nix/store/i76pr1cz0za3i9r6xq518bqqvd2raspw-foo.drv": {
    "outputs": {
      "out": {
        "path": "/nix/store/gczb4qrag22harvv693wwnflqy7lx5pb-foo"
      }
    },
    "inputSrcs": [
      "/nix/store/lb0n38r2b20r8rl1k45a7s4pj6ny22f7-builder.sh"
    ],
    "inputDrvs": {
      "/nix/store/hcgwbx42mcxr7ksnv0i1fg7kw6jvxshb-bash-4.4-p19.drv": [
        "out"
      ]
    },
    "platform": "x86_64-linux",
    "builder": "/nix/store/q1g0rl8zfmz7r371fp5p42p4acmv297d-bash-4.4-p19/bin/bash",
    "args": [
      "/nix/store/lb0n38r2b20r8rl1k45a7s4pj6ny22f7-builder.sh"
    ],
    "env": {
      "builder": "/nix/store/q1g0rl8zfmz7r371fp5p42p4acmv297d-bash-4.4-p19/bin/bash",
      "name": "foo",
      "out": "/nix/store/gczb4qrag22harvv693wwnflqy7lx5pb-foo",
      "system": "x86_64-linux"
    }
  }
}
</code></pre>
<p>Much like the usual
.drv, except that there's a list of arguments in there passed to the
builder (bash) with <code>builder.sh</code>... In the nix store..? Nix
automatically copies files or directories needed for the build into the
store to ensure that they are not changed during the build process and
that the deployment is stateless and independent of the building
machine. <code>builder.sh</code> is not only in the arguments passed to the
builder, it's also in the input derivations.</p>
<p>Given that <code>builder.sh</code> is a plain file, it has no .drv associated with
it. The store path is computed based on the filename and on the hash of
its contents. Store paths are covered in detail in <a href="18-nix-store-paths.html">a later
pill</a>.</p>
<h2 id="packaging-a-simple-c-program"><a class="header" href="#packaging-a-simple-c-program">Packaging a simple C program</a></h2>
<p>Start off by writing a simple C program called <code>simple.c</code>:</p>
<pre><code>void main() {
  puts("Simple!");
}
</code></pre>
<p>And its <code>simple_builder.sh</code>:</p>
<pre><code>export PATH="$coreutils/bin:$gcc/bin"
mkdir $out
gcc -o $out/simple $src
</code></pre>
<p>Don't worry too much about where those variables come from yet; let's
write the derivation and build it:</p>
<pre><code>nix-repl&gt; :l &lt;nixpkgs&gt;
nix-repl&gt; simple = derivation { name = "simple"; builder = "${bash}/bin/bash"; args = [ ./simple_builder.sh ]; gcc = gcc; coreutils = coreutils; src = ./simple.c; system = builtins.currentSystem; }
nix-repl&gt; :b simple
this derivation produced the following outputs:

  out -&gt; /nix/store/ni66p4jfqksbmsl616llx3fbs1d232d4-simple
</code></pre>
<p>Now you can run
<code>/nix/store/ni66p4jfqksbmsl616llx3fbs1d232d4-simple/simple</code> in your
shell.</p>
<h2 id="explanation"><a class="header" href="#explanation">Explanation</a></h2>
<p>We added two new attributes to the derivation call, <code>gcc</code> and
<code>coreutils</code>. In <code>gcc = gcc;</code>, the name on the left is the name in the
derivation set, and the name on the right refers to the gcc derivation
from nixpkgs. The same applies for coreutils.</p>
<p>We also added the <code>src</code> attribute, nothing magical --- it's just a
name, to which the path <code>./simple.c</code> is assigned. Like
<code>simple-builder.sh</code>, <code>simple.c</code> will be added to the store.</p>
<p>The trick: every attribute in the set passed to <code>derivation</code> will be
converted to a string and passed to the builder as an environment
variable. This is how the builder gains access to coreutils and gcc:
when converted to strings, the derivations evaluate to their output
paths, and appending <code>/bin</code> to these leads us to their binaries.</p>
<p>The same goes for the <code>src</code> variable. <code>$src</code> is the path to <code>simple.c</code>
in the nix store. As an exercise, pretty print the .drv file. You'll
see <code>simple_builder.sh</code> and <code>simple.c</code> listed in the input derivations,
along with bash, gcc and coreutils .drv files. The newly added
environment variables described above will also appear.</p>
<p>In <code>simple_builder.sh</code> we set the <code>PATH</code> for gcc and coreutils binaries,
so that our build script can find the necessary utilities like mkdir and
gcc.</p>
<p>We then create <code>$out</code> as a directory and place the binary inside it.
Note that gcc is found via the <code>PATH</code> environment variable, but it could
equivalently be referenced explicitly using <code>$gcc/bin/gcc</code>.</p>
<h2 id="enough-of-nix-repl"><a class="header" href="#enough-of-nix-repl">Enough of <code>nix repl</code></a></h2>
<p>Drop out of nix repl and write a file <code>simple.nix</code>:</p>
<pre><code>let
  pkgs = import &lt;nixpkgs&gt; { };
in
pkgs.stdenv.mkDerivation {
  name = "simple";
  builder = "${pkgs.bash}/bin/bash";
  args = [ ./simple_builder.sh ];
  gcc = pkgs.gcc;
  coreutils = pkgs.coreutils;
  src = ./simple.c;
  system = builtins.currentSystem;
}
</code></pre>
<p>Now you can build it with <code>nix-build simple.nix</code>. This will create a
symlink <code>result</code> in the current directory, pointing to the out path of
the derivation.</p>
<p>nix-build does two jobs:</p>
<ul>
<li>
<p><a href="https://nixos.org/manual/nix/stable/command-ref/nix-instantiate.html"> nix-instantiate
</a>:
parse and evaluate <code>simple.nix</code> and return the .drv file
corresponding to the parsed derivation set</p>
</li>
<li>
<p><a href="https://nixos.org/manual/nix/stable/command-ref/nix-store.html#operation---realise"> <code>nix-store -r</code>
</a>:
realise the .drv file, which actually builds it.</p>
</li>
</ul>
<p>Finally, it creates the symlink.</p>
<p>In the second line of <code>simple.nix</code>, we have an <code>import</code> function call.
Recall that <code>import</code> accepts one argument, a nix file to load. In this
case, the contents of the file evaluate to a function.</p>
<p>Afterwards, we call the function with the empty set. We saw this already
in <a href="05-functions-and-imports.html">the fifth pill</a>. To reiterate:
<code>import &lt;nixpkgs&gt; {}</code> is calling two functions, not one. Reading it as
<code>(import &lt;nixpkgs&gt;) {}</code> makes this clearer.</p>
<p>The value returned by the nixpkgs function is a set; more specifically,
it's a set of derivations. Calling <code>import &lt;nixpkgs&gt; {}</code> into a
<code>let</code>-expression creates the local variable <code>pkgs</code> and brings it into
scope. This has an effect similar to the <code>:l &lt;nixpkgs&gt;</code> we used in nix
repl, in that it allows us to easily access derivations such as <code>bash</code>,
<code>gcc</code>, and <code>coreutils</code>, but those derivations will have to be explicitly
referred to as members of the <code>pkgs</code> set (e.g., <code>pkgs.bash</code> instead of
just <code>bash</code>).</p>
<p>Below is a revised version of the <code>simple.nix</code> file, using the <code>inherit</code>
keyword:</p>
<pre><code>let
  pkgs = import &lt;nixpkgs&gt; { };
in
pkgs.stdenv.mkDerivation {
  name = "simple";
  builder = "${pkgs.bash}/bin/bash";
  args = [ ./simple_builder.sh ];
  inherit (pkgs) gcc coreutils;
  src = ./simple.c;
  system = builtins.currentSystem;
}
</code></pre>
<p>Here we also take the opportunity to introduce the <a href="https://nixos.org/manual/nix/stable/expressions/language-constructs.html#inheriting-attributes"><code>inherit</code>
keyword</a>.
<code>inherit foo;</code> is equivalent to <code>foo = foo;</code>. Similarly,
<code>inherit gcc coreutils;</code> is equivalent to
<code>gcc = gcc; coreutils = coreutils;</code>. Lastly,
<code>inherit (pkgs) gcc coreutils;</code> is equivalent to
<code>gcc = pkgs.gcc; coreutils = pkgs.coreutils;</code>.</p>
<p>This syntax only makes sense inside sets. There's no magic involved,
it's simply a convenience to avoid repeating the same name for both the
attribute name and the value in scope.</p>
<h2 id="next-pill-6"><a class="header" href="#next-pill-6">Next pill</a></h2>
<p>We will generalize the builder. You may have noticed that we wrote two
separate <code>builder.sh</code> scripts in this post. We would like to have a
generic builder script instead, especially since each build script goes
in the nix store: a bit of a waste.</p>
<p><em>Is it really that hard to package stuff in Nix? No</em>, here we're
studying the fundamentals of Nix.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-builders"><a class="header" href="#generic-builders">Generic Builders</a></h1>
<p>Welcome to the 8th Nix pill. In the previous <a href="07-working-derivation.html">7th
pill</a> we successfully built a derivation. We wrote
a builder script that compiled a C file and installed the binary under
the nix store.</p>
<p>In this post, we will generalize the builder script, write a Nix
expression for <a href="https://www.gnu.org/software/hello/">GNU hello world</a>
and create a wrapper around the derivation built-in function.</p>
<h2 id="packaging-gnu-hello-world"><a class="header" href="#packaging-gnu-hello-world">Packaging GNU hello world</a></h2>
<p>In the previous pill we packaged a simple .c file, which was being
compiled with a raw gcc call. That's not a good example of a project.
Many use autotools, and since we're going to generalize our builder, it
would be better to do it with the most used build system.</p>
<p><a href="https://www.gnu.org/software/hello/">GNU hello world</a>, despite its
name, is a simple yet complete project which uses autotools. Fetch the
latest tarball here:
<a href="https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz">https://ftp.gnu.org/gnu/hello/hello-2.12.1.tar.gz</a>.</p>
<p>Let's create a builder script for GNU hello world, hello_builder.sh:</p>
<pre><code>export PATH="$gnutar/bin:$gcc/bin:$gnumake/bin:$coreutils/bin:$gawk/bin:$gzip/bin:$gnugrep/bin:$gnused/bin:$bintools/bin"
tar -xzf $src
cd hello-2.12.1
./configure --prefix=$out
make
make install
</code></pre>
<p>And the derivation hello.nix:</p>
<pre><code>let
  pkgs = import &lt;nixpkgs&gt; { };
in
derivation {
  name = "hello";
  builder = "${pkgs.bash}/bin/bash";
  args = [ ./hello_builder.sh ];
  inherit (pkgs)
    gnutar
    gzip
    gnumake
    gcc
    coreutils
    gawk
    gnused
    gnugrep
    ;
  bintools = pkgs.binutils.bintools;
  src = ./hello-2.12.1.tar.gz;
  system = builtins.currentSystem;
}
</code></pre>
<div class="info">
<h4 id="nix-on-darwin"><a class="header" href="#nix-on-darwin">Nix on darwin</a></h4>
<p>Darwin (i.e. macOS) builds typically use <code>clang</code> rather than <code>gcc</code> for a
C compiler. We can adapt this early example for darwin by using this
modified version of <code>hello.nix</code>:</p>
<pre><code>let
  pkgs = import &lt;nixpkgs&gt; { };
in
derivation {
  name = "hello";
  builder = "${pkgs.bash}/bin/bash";
  args = [ ./hello_builder.sh ];
  inherit (pkgs)
    gnutar
    gzip
    gnumake
    coreutils
    gawk
    gnused
    gnugrep
    ;
  gcc = pkgs.clang;
  bintools = pkgs.clang.bintools.bintools_bin;
  src = ./hello-2.12.1.tar.gz;
  system = builtins.currentSystem;
}
</code></pre>
<p>Later, we will show how Nix can automatically handle these differences.
For now, please be just aware that changes similar to the above may be
needed in what follows.</p>
</div>
<p>Now build it with <code>nix-build hello.nix</code> and you can launch
<code>result/bin/hello</code>. Nothing easier, but do we have to create a
builder.sh for each package? Do we always have to pass the dependencies
to the <code>derivation</code> function?</p>
<p>Please note the <code>--prefix=$out</code> we were talking about in the <a href="07-working-derivation.html">previous
pill</a>.</p>
<h2 id="a-generic-builder"><a class="header" href="#a-generic-builder">A generic builder</a></h2>
<p>Let's create a generic <code>builder.sh</code> for autotools projects:</p>
<pre><code>set -e
unset PATH
for p in $buildInputs; do
  export PATH=$p/bin${PATH:+:}$PATH
done

tar -xf $src

for d in *; do
  if [ -d "$d" ]; then
    cd "$d"
    break
  fi
done

./configure --prefix=$out
make
make install
</code></pre>
<p>What do we do here?</p>
<ol>
<li>
<p>Exit the build on any error with <code>set -e</code>.</p>
</li>
<li>
<p>First <code>unset PATH</code>, because it's initially set to a non-existent
path.</p>
</li>
<li>
<p>We'll see this below in detail, however for each path in
<code>$buildInputs</code>, we append <code>bin</code> to <code>PATH</code>.</p>
</li>
<li>
<p>Unpack the source.</p>
</li>
<li>
<p>Find a directory where the source has been unpacked and <code>cd</code> into
it.</p>
</li>
<li>
<p>Once we're set up, compile and install.</p>
</li>
</ol>
<p>As you can see, there's no reference to "hello" in the builder
anymore. It still makes several assumptions, but it's certainly more
generic.</p>
<p>Now let's rewrite <code>hello.nix</code>:</p>
<pre><code>let
  pkgs = import &lt;nixpkgs&gt; { };
in
derivation {
  name = "hello";
  builder = "${pkgs.bash}/bin/bash";
  args = [ ./builder.sh ];
  buildInputs = with pkgs; [
    gnutar
    gzip
    gnumake
    gcc
    coreutils
    gawk
    gnused
    gnugrep
    binutils.bintools
  ];
  src = ./hello-2.12.1.tar.gz;
  system = builtins.currentSystem;
}
</code></pre>
<p>All clear, except that buildInputs. However it's easier than any black
magic you are thinking of at this moment.</p>
<p>Nix is able to convert a list to a string. It first converts the
elements to strings, and then concatenates them separated by a space:</p>
<pre><code>nix-repl&gt; builtins.toString 123
"123"
nix-repl&gt; builtins.toString [ 123 456 ]
"123 456"
</code></pre>
<p>Recall that derivations can be converted to a string, hence:</p>
<pre><code>nix-repl&gt; :l &lt;nixpkgs&gt;
Added 3950 variables.
nix-repl&gt; builtins.toString gnugrep
"/nix/store/g5gdylclfh6d224kqh9sja290pk186xd-gnugrep-2.14"
nix-repl&gt; builtins.toString [ gnugrep gnused ]
"/nix/store/g5gdylclfh6d224kqh9sja290pk186xd-gnugrep-2.14 /nix/store/krgdc4sknzpw8iyk9p20lhqfd52kjmg0-gnused-4.2.2"
</code></pre>
<p>Simple! The buildInputs variable is a string with out paths separated by
space, perfect for bash usage in a for loop.</p>
<h2 id="a-more-convenient-derivation-function"><a class="header" href="#a-more-convenient-derivation-function">A more convenient derivation function</a></h2>
<p>We managed to write a builder that can be used for multiple autotools
projects. But in the hello.nix expression we are specifying tools that
are common to more projects; we don't want to pass them every time.</p>
<p>A natural approach would be to create a function that accepts an
attribute set, similar to the one used by the derivation function, and
merge it with another attribute set containing values common to many
projects.</p>
<p>Create <code>autotools.nix</code>:</p>
<pre><code>pkgs: attrs:
let
  defaultAttrs = {
    builder = "${pkgs.bash}/bin/bash";
    args = [ ./builder.sh ];
    baseInputs = with pkgs; [
      gnutar
      gzip
      gnumake
      gcc
      coreutils
      gawk
      gnused
      gnugrep
      binutils.bintools
    ];
    buildInputs = [ ];
    system = builtins.currentSystem;
  };
in
derivation (defaultAttrs // attrs)
</code></pre>
<p>Ok now we have to remember a little about <a href="05-functions-and-imports.html">Nix
functions</a>. The whole nix expression of this
<code>autotools.nix</code> file will evaluate to a function. This function accepts
a parameter <code>pkgs</code>, then returns a function which accepts a parameter
<code>attrs</code>.</p>
<p>The body of the function is simple, yet at first sight it might be hard
to grasp:</p>
<ol>
<li>
<p>First drop in the scope the magic <code>pkgs</code> attribute set.</p>
</li>
<li>
<p>Within a let expression we define a helper variable, <code>defaultAttrs</code>,
which serves as a set of common attributes used in derivations.</p>
</li>
<li>
<p>Finally we create the derivation with that strange expression,
(<code>defaultAttrs // attrs</code>).</p>
</li>
</ol>
<p>The <a href="https://nixos.org/manual/nix/stable/expressions/language-operators.html">//
operator</a>
is an operator between two sets. The result is the union of the two
sets. In case of conflicts between attribute names, the value on the
right set is preferred.</p>
<p>So we use <code>defaultAttrs</code> as base set, and add (or override) the
attributes from <code>attrs</code>.</p>
<p>A couple of examples ought to be enough to clear out the behavior of the
operator:</p>
<pre><code>nix-repl&gt; { a = "b"; } // { c = "d"; }
{ a = "b"; c = "d"; }
nix-repl&gt; { a = "b"; } // { a = "c"; }
{ a = "c"; }
</code></pre>
<p><strong>Exercise:</strong> Complete the new <code>builder.sh</code> by adding <code>$baseInputs</code> in
the <code>for</code> loop together with <code>$buildInputs</code>. As you noticed, we passed
that new variable in the derivation. Instead of merging buildInputs with
the base ones, we prefer to preserve buildInputs as seen by the caller,
so we keep them separated. Just a matter of choice.</p>
<p>Then we rewrite <code>hello.nix</code> as follows:</p>
<pre><code>let
  pkgs = import &lt;nixpkgs&gt; { };
  mkDerivation = import ./autotools.nix pkgs;
in
mkDerivation {
  name = "hello";
  src = ./hello-2.12.1.tar.gz;
}
</code></pre>
<p>Finally! We got a very simple description of a package! Below are a
couple of remarks that you may find useful as you're continuing to
understand the nix language:</p>
<ul>
<li>
<p>We assigned to pkgs the import that we did in the previous
expressions in the "with". Don't be afraid, it's that
straightforward.</p>
</li>
<li>
<p>The mkDerivation variable is a nice example of partial application,
look at it as (<code>import ./autotools.nix</code>) <code>pkgs</code>. First we import the
expression, then we apply the <code>pkgs</code> parameter. That will give us a
function that accepts the attribute set <code>attrs</code>.</p>
</li>
<li>
<p>We create the derivation specifying only name and src. If the
project eventually needed other dependencies to be in PATH, then we
would simply add those to buildInputs (not specified in hello.nix
because empty).</p>
</li>
</ul>
<p>Note we didn't use any other library. Special C flags may be needed to
find include files of other libraries at compile time, and ld flags at
link time.</p>
<h2 id="conclusion-4"><a class="header" href="#conclusion-4">Conclusion</a></h2>
<p>Nix gives us the bare metal tools for creating derivations, setting up a
build environment and storing the result in the nix store.</p>
<p>Out of this pill we managed to create a generic builder for autotools
projects, and a function <code>mkDerivation</code> that composes by default the
common components used in autotools projects instead of repeating them
in all the packages we would write.</p>
<p>We are familiarizing ourselves with the way a Nix system grows up: it's
about creating and composing derivations with the Nix language.</p>
<p>Analogy: in C you create objects in the heap, and then you
compose them inside new objects. Pointers are used to refer to other
objects.</p>
<p>In Nix you create derivations stored in the nix store, and then you
compose them by creating new derivations. Store paths are used to refer
to other derivations.</p>
<h2 id="next-pill-7"><a class="header" href="#next-pill-7">Next pill</a></h2>
<p>...we will talk a little about runtime dependencies. Is the GNU hello
world package self-contained? What are its runtime dependencies? We only
specified build dependencies by means of using other derivations in the
"hello" derivation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="automatic-runtime-dependencies"><a class="header" href="#automatic-runtime-dependencies">Automatic Runtime Dependencies</a></h1>
<p>Welcome to the 9th Nix pill. In the previous <a href="08-generic-builders.html">8th
pill</a> we wrote a generic builder for autotools
projects. We fed in build dependencies and a source tarball, and we
received a Nix derivation as a result.</p>
<p>Today we stop by the GNU <code>hello</code> program to analyze build and runtime
dependencies, and we enhance our builder to eliminate unnecessary
runtime dependencies.</p>
<h2 id="build-dependencies"><a class="header" href="#build-dependencies">Build dependencies</a></h2>
<p>Let's start analyzing build dependencies for our GNU <code>hello</code> package:</p>
<pre><code>$ nix-instantiate hello.nix
/nix/store/z77vn965a59irqnrrjvbspiyl2rph0jp-hello.drv
$ nix-store -q --references /nix/store/z77vn965a59irqnrrjvbspiyl2rph0jp-hello.drv
/nix/store/0q6pfasdma4as22kyaknk4kwx4h58480-hello-2.10.tar.gz
/nix/store/1zcs1y4n27lqs0gw4v038i303pb89rw6-coreutils-8.21.drv
/nix/store/2h4b30hlfw4fhqx10wwi71mpim4wr877-gnused-4.2.2.drv
/nix/store/39bgdjissw9gyi4y5j9wanf4dbjpbl07-gnutar-1.27.1.drv
/nix/store/7qa70nay0if4x291rsjr7h9lfl6pl7b1-builder.sh
/nix/store/g6a0shr58qvx2vi6815acgp9lnfh9yy8-gnugrep-2.14.drv
/nix/store/jdggv3q1sb15140qdx0apvyrps41m4lr-bash-4.2-p45.drv
/nix/store/pglhiyp1zdbmax4cglkpz98nspfgbnwr-gnumake-3.82.drv
/nix/store/q9l257jn9lndbi3r9ksnvf4dr8cwxzk7-gawk-4.1.0.drv
/nix/store/rgyrqxz1ilv90r01zxl0sq5nq0cq7v3v-binutils-2.23.1.drv
/nix/store/qzxhby795niy6wlagfpbja27dgsz43xk-gcc-wrapper-4.8.3.drv
/nix/store/sk590g7fv53m3zp0ycnxsc41snc2kdhp-gzip-1.6.drv
</code></pre>
<p>It has precisely the derivations referenced in the <code>derivation</code>
function; nothing more, nothing less. Of course, we may not use some of
them at all. However, given that our generic <code>mkDerivation</code> function
always pulls such dependencies (think of it like
<a href="https://packages.debian.org/unstable/build-essential">build-essential</a>
from Debian), we will already have these packages in the nix store for
any future packages that need them.</p>
<p>Why are we looking at <code>.drv</code> files? Because the <code>hello.drv</code> file is the
representation of the build action that builds the <code>hello</code> out path. As
such, it contains the input derivations needed before building <code>hello</code>.</p>
<h2 id="digression-about-nar-files"><a class="header" href="#digression-about-nar-files">Digression about NAR files</a></h2>
<p>The <code>NAR</code> format is the "Nix ARchive". This format was designed due to
existing archive formats, such as <code>tar</code>, being insufficient. Nix
benefits from deterministic build tools, but commonly used archivers
lack this property: they add padding, they do not sort files, they add
timestamps, and so on. This can result in directories containing
bit-identical files turning into non-bit-identical archives, which leads
to different hashes.</p>
<p>Thus the <code>NAR</code> format was developed as a simple, deterministic archive
format. <code>NAR</code>s are used extensively within Nix, as we will see below.</p>
<p>For more rationale and implementation details behind <code>NAR</code> see
<a href="http://nixos.org/~eelco/pubs/phd-thesis.pdf">Dolstra's PhD Thesis</a>.</p>
<p>To create NAR archives from store paths, we can use <code>nix-store --dump</code>
and <code>nix-store --restore</code>.</p>
<h2 id="runtime-dependencies"><a class="header" href="#runtime-dependencies">Runtime dependencies</a></h2>
<p>We now note that Nix automatically recognized build dependencies once
our <code>derivation</code> call referred to them, but we never specified the
runtime dependencies.</p>
<p>Nix handles runtime dependencies for us automatically. The technique it
uses to do so may seem fragile at first glance, but it works so well
that the NixOS operating system is built off of it. The underlying
mechanism relies on the hash of the store paths. It proceeds in three
steps:</p>
<ol>
<li>
<p>Dump the derivation as a NAR. Recall that this is a serialization of
the derivation output -- meaning this works fine whether the output
is a single file or a directory.</p>
</li>
<li>
<p>For each build dependency <code>.drv</code> and its relative out path, search
the contents of the NAR for this out path.</p>
</li>
<li>
<p>If the path is found, then it's a runtime dependency.</p>
</li>
</ol>
<p>The snippet below shows the dependencies for <code>hello</code>.</p>
<pre><code>$ nix-instantiate hello.nix
/nix/store/z77vn965a59irqnrrjvbspiyl2rph0jp-hello.drv
$ nix-store -r /nix/store/z77vn965a59irqnrrjvbspiyl2rph0jp-hello.drv
/nix/store/a42k52zwv6idmf50r9lps1nzwq9khvpf-hello
$ nix-store -q --references /nix/store/a42k52zwv6idmf50r9lps1nzwq9khvpf-hello
/nix/store/94n64qy99ja0vgbkf675nyk39g9b978n-glibc-2.19
/nix/store/8jm0wksask7cpf85miyakihyfch1y21q-gcc-4.8.3
/nix/store/a42k52zwv6idmf50r9lps1nzwq9khvpf-hello
</code></pre>
<p>We see that <code>glibc</code> and <code>gcc</code> are runtime dependencies. Intuitively,
<code>gcc</code> shouldn't be in this list! Displaying the printable strings in
the <code>hello</code> binary shows that the out path of <code>gcc</code> does indeed appear:</p>
<pre><code>$ strings result/bin/hello|grep gcc
/nix/store/94n64qy99ja0vgbkf675nyk39g9b978n-glibc-2.19/lib:/nix/store/8jm0wksask7cpf85miyakihyfch1y21q-gcc-4.8.3/lib64
</code></pre>
<p>This is why Nix added <code>gcc</code>. But why is that path present in the first
place? The answer is that it is the <a href="http://en.wikipedia.org/wiki/Rpath">ld
rpath</a>: the list of directories
where libraries can be found at runtime. In other distributions, this is
usually not abused. But in Nix, we have to refer to particular versions
of libraries, and thus the rpath has an important role.</p>
<p>The build process adds the <code>gcc</code> lib path thinking it may be useful at
runtime, but this isn't necessary. To address issues like these, Nix
provides a tool called <a href="https://nixos.org/patchelf.html">patchelf</a>,
which reduces the rpath to the paths that are actually used by the
binary.</p>
<p>Even after reducing the rpath, the <code>hello</code> binary would still depend
upon <code>gcc</code> because of some debugging information. This unnecessarily
increases the size of our runtime dependencies. We'll explore how
<code>strip</code> can help us with that in the next section.</p>
<h2 id="another-phase-in-the-builder"><a class="header" href="#another-phase-in-the-builder">Another phase in the builder</a></h2>
<p>We will add a new phase to our autotools builder. The builder has six
phases already:</p>
<ol>
<li>
<p>The "environment setup" phase</p>
</li>
<li>
<p>The "unpack phase": we unpack the sources in the current directory
(remember, Nix changes to a temporary directory first)</p>
</li>
<li>
<p>The "change directory" phase, where we change source root to the
directory that has been unpacked</p>
</li>
<li>
<p>The "configure" phase: <code>./configure</code></p>
</li>
<li>
<p>The "build" phase: <code>make</code></p>
</li>
<li>
<p>The "install" phase: <code>make install</code></p>
</li>
</ol>
<p>Now we will add a new phase after the installation phase, which we call
the "fixup" phase. At the end of the <code>builder.sh</code>, we append:</p>
<pre><code>find $out -type f -exec patchelf --shrink-rpath '{}' \; -exec strip '{}' \; 2&gt;/dev/null
</code></pre>
<p>That is, for each file we run <code>patchelf --shrink-rpath</code> and <code>strip</code>.
Note that we used two new commands here, <code>find</code> and <code>patchelf</code>. These
must be added to our derivation.</p>
<p><strong>Exercise:</strong> Add <code>findutils</code> and <code>patchelf</code> to the <code>baseInputs</code> of
<code>autotools.nix</code>.</p>
<p>Now, we rebuild <code>hello.nix</code>...</p>
<pre><code>$ nix-build hello.nix
[...]
$ nix-store -q --references result
/nix/store/94n64qy99ja0vgbkf675nyk39g9b978n-glibc-2.19
/nix/store/md4a3zv0ipqzsybhjb8ndjhhga1dj88x-hello
</code></pre>
<p>and we see that <code>glibc</code> is a runtime dependency. This is exactly what we
wanted.</p>
<p>The package is self-contained. This means that we can copy its closure
onto another machine and we will be able to run it. Remember, only a
very few components under the <code>/nix/store</code> are required to <a href="02-install-on-your-running.html">run
nix</a>. The <code>hello</code> binary will use the
exact version of <code>glibc</code> library and interpreter referred to in the
binary, rather than the system one:</p>
<pre><code>$ ldd result/bin/hello
 linux-vdso.so.1 (0x00007fff11294000)
 libc.so.6 =&gt; /nix/store/94n64qy99ja0vgbkf675nyk39g9b978n-glibc-2.19/lib/libc.so.6 (0x00007f7ab7362000)
 /nix/store/94n64qy99ja0vgbkf675nyk39g9b978n-glibc-2.19/lib/ld-linux-x86-64.so.2 (0x00007f7ab770f000)
</code></pre>
<p>Of course, the executable will run fine as long as everything is under
the <code>/nix/store</code> path.</p>
<h2 id="conclusion-5"><a class="header" href="#conclusion-5">Conclusion</a></h2>
<p>We saw some of the tools Nix provides, along with their features. In
particular, we saw how Nix is able to compute runtime dependencies
automatically. This is not limited to only shared libraries, but can
also reference executables, scripts, Python libraries, and so forth.</p>
<p>Approaching builds in this way makes packages self-contained, ensuring
(apart from data and configuration) that copying the runtime closure
onto another machine is sufficient to run the program. This enables us
to run programs without installation using <code>nix-shell</code>, and forms the
basis for <a href="https://nixos.org/manual/nix/stable/introduction.html">reliable deployment in the
cloud</a>.</p>
<h2 id="next-pill-8"><a class="header" href="#next-pill-8">Next pill</a></h2>
<p>The next pill will introduce <code>nix-shell</code>. With <code>nix-build</code>, we've
always built derivations from scratch: the source gets unpacked,
configured, built, and installed. But this can take a long time for
large packages. What if we want to apply some small changes and compile
incrementally instead, yet still want to keep a self-contained
environment similar to <code>nix-build</code>? <code>nix-shell</code> enables this.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="developing-with-nix-shell"><a class="header" href="#developing-with-nix-shell">Developing with <code>nix-shell</code></a></h1>
<p>Welcome to the 10th Nix pill. In the previous <a href="09-automatic-runtime.html">9th
pill</a> we saw one of the powerful
features of Nix: automatic discovery of runtime dependencies. We also
finalized the GNU <code>hello</code> package.</p>
<p>In this pill, we will introduce the <code>nix-shell</code> tool and use it to hack
on the GNU <code>hello</code> program. We will see how <code>nix-shell</code> gives us an
isolated environment while we modify the source files of the project,
similar to how <code>nix-build</code> gave us an isolated environment while
building the derivation.</p>
<p>Finally, we will modify our builder to work more ergonomically with a
<code>nix-shell</code>-focused workflow.</p>
<h2 id="what-is-nix-shell"><a class="header" href="#what-is-nix-shell">What is <code>nix-shell</code>?</a></h2>
<p>The
<a href="https://nixos.org/manual/nix/stable/command-ref/nix-shell.html">nix-shell</a>
tool drops us in a shell after setting up the environment variables
necessary to hack on a derivation. It does not build the derivation; it
only serves as a preparation so that we can run the build steps
manually.</p>
<p>Recall that in a nix environment, we don't have access to libraries or
programs unless they have been installed with <code>nix-env</code>. However,
installing libraries with <code>nix-env</code> is not good practice. We prefer to
have isolated environments for development, which <code>nix-shell</code> provides
for us.</p>
<p>We can call <code>nix-shell</code> on any Nix expression which returns a
derivation, but the resulting <code>bash</code> shell's <code>PATH</code> does not have the
utilities we want:</p>
<pre><code>$ nix-shell hello.nix
[nix-shell]$ make
bash: make: command not found
[nix-shell]$ echo $baseInputs
/nix/store/jff4a6zqi0yrladx3kwy4v6844s3swpc-gnutar-1.27.1 [...]
</code></pre>
<p>This shell is rather useless. It would be reasonable to expect that the
GNU <code>hello</code> build inputs are available in <code>PATH</code>, including GNU <code>make</code>,
but this is not the case.</p>
<p>However, we do have the environment variables that we set in the
derivation, like <code>$baseInputs</code>, <code>$buildInputs</code>, <code>$src</code>, and so on.</p>
<p>This means that we can <code>source</code> our <code>builder.sh</code>, and it will build the
derivation. You may get an error in the installation phase, because your
user may not have the permission to write to <code>/nix/store</code>:</p>
<pre><code>[nix-shell]$ source builder.sh
...
</code></pre>
<p>The derivation didn't install, but it did build. Note the following:</p>
<ul>
<li>
<p>We sourced <code>builder.sh</code> and it ran all of the build steps, including
setting up the <code>PATH</code> for us.</p>
</li>
<li>
<p>The working directory is no longer a temp directory created by
<code>nix-build</code>, but is instead the directory in which we entered the
shell. Therefore, <code>hello-2.10</code> has been unpacked in the current
directory.</p>
</li>
</ul>
<p>We are able to <code>cd</code> into <code>hello-2.10</code> and type <code>make</code>, because <code>make</code> is
now available.</p>
<p>The take-away is that <code>nix-shell</code> drops us in a shell with the same (or
very similar) environment used to run the builder.</p>
<h2 id="a-builder-for-nix-shell"><a class="header" href="#a-builder-for-nix-shell">A builder for nix-shell</a></h2>
<p>The previous steps require some manual commands to be run and are not
optimized for a workflow centered on <code>nix-shell</code>. We will now improve
our builder to be more <code>nix-shell</code> friendly.</p>
<p>There are a few things that we would like to change.</p>
<p>First, when we <code>source</code>d the <code>builder.sh</code> file, we obtained the file in
the current directory. What we really wanted was the <code>builder.sh</code> that
is stored in the nix store, as this is the file that would be used by
<code>nix-build</code>. To achieve this, the correct technique is to pass an
environment variable through the derivation. (Note that <code>$builder</code> is
already defined, but it points to the bash executable rather than our
<code>builder.sh</code>. Our <code>builder.sh</code> is passed as an argument to bash.)</p>
<p>Second, we don't want to run the whole builder: we only want to setup
the necessary environment for manually building the project. Thus, we
can break <code>builder.sh</code> into two files: a <code>setup.sh</code> for setting up the
environment, and the real <code>builder.sh</code> that <code>nix-build</code> expects.</p>
<p>During our refactoring, we will wrap the build phases in functions to
give more structure to our design. Additionally, we'll move the
<code>set -e</code> to the builder file instead of the setup file. The <code>set -e</code> is
annoying in <code>nix-shell</code>, as it will terminate the shell if an error is
encountered (such as a mistyped command.)</p>
<p>Here is our modified <code>autotools.nix</code>. Noteworthy is the
<code>setup = ./setup.sh;</code> attribute in the derivation, which adds <code>setup.sh</code>
to the nix store and correspondingly adds a <code>$setup</code> environment
variable in the builder.</p>
<pre><code>pkgs: attrs:
let
  defaultAttrs = {
    builder = "${pkgs.bash}/bin/bash";
    args = [ ./builder.sh ];
    setup = ./setup.sh;
    baseInputs = with pkgs; [
      gnutar
      gzip
      gnumake
      gcc
      coreutils
      gawk
      gnused
      gnugrep
      binutils.bintools
      patchelf
      findutils
    ];
    buildInputs = [ ];
    system = builtins.currentSystem;
  };
in
derivation (defaultAttrs // attrs)
</code></pre>
<p>Thanks to that, we can split <code>builder.sh</code> into <code>setup.sh</code> and
<code>builder.sh</code>. What <code>builder.sh</code> does is <code>source</code> <code>$setup</code> and call the
<code>genericBuild</code> function. Everything else is just some changes to the
bash script.</p>
<p>Here is the modified <code>builder.sh</code>:</p>
<pre><code>set -e
source $setup
genericBuild
</code></pre>
<p>Here is the newly added <code>setup.sh</code>:</p>
<pre><code>unset PATH
for p in $baseInputs $buildInputs; do
  export PATH=$p/bin${PATH:+:}$PATH
done

function unpackPhase() {
  tar -xzf $src

  for d in *; do
    if [ -d "$d" ]; then
      cd "$d"
      break
    fi
  done
}

function configurePhase() {
  ./configure --prefix=$out
}

function buildPhase() {
  make
}

function installPhase() {
  make install
}

function fixupPhase() {
  find $out -type f -exec patchelf --shrink-rpath '{}' \; -exec strip '{}' \; 2&gt;/dev/null
}

function genericBuild() {
  unpackPhase
  configurePhase
  buildPhase
  installPhase
  fixupPhase
}
</code></pre>
<p>Finally, here is <code>hello.nix</code>:</p>
<pre><code>let
  pkgs = import &lt;nixpkgs&gt; { };
  mkDerivation = import ./autotools.nix pkgs;
in
mkDerivation {
  name = "hello";
  src = ./hello-2.12.1.tar.gz;
}
</code></pre>
<p>Now back to nix-shell:</p>
<pre><code>$ nix-shell hello.nix
[nix-shell]$ source $setup
[nix-shell]$
</code></pre>
<p>Now, for example, you can run <code>unpackPhase</code> which unpacks <code>$src</code> and
enters the directory. And you can run commands like <code>./configure</code>,
<code>make</code>, and so forth manually, or run phases with their respective
functions.</p>
<p>The process is that straightforward. <code>nix-shell</code> builds the <code>.drv</code> file
and its input dependencies, then drops into a shell by setting up the
environment variables necessary to build the <code>.drv</code>. In particular, the
environment variables in the shell match those passed to the
<code>derivation</code> function.</p>
<h2 id="conclusion-6"><a class="header" href="#conclusion-6">Conclusion</a></h2>
<p>With <code>nix-shell</code> we are able to drop into an isolated environment
suitable for developing a project. This environment provides the
necessary dependencies for the development shell, similar to how
<code>nix-build</code> provides the necessary dependencies to a builder.
Additionally, we can build and debug the project manually, executing
step-by-step like we would in any other operating system. Note that we
never installed tools such <code>gcc</code> or <code>make</code> system-wide; these tools and
libraries are isolated and available per-build.</p>
<h2 id="next-pill-9"><a class="header" href="#next-pill-9">Next pill</a></h2>
<p>In the next pill, we will clean up the nix store. We have written and
built derivations which add to the nix store, but until now we haven't
worried about cleaning up the used space in the store.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="garbage-collector"><a class="header" href="#garbage-collector">The Garbage Collector</a></h1>
<p>Welcome to the 11th Nix pill. In the previous <a href="10-developing-with-nix-shell.html">10th
pill</a>, we drew a parallel between the
isolated build environment provided by <code>nix-build</code> and the isolated
development shell provided by <code>nix-shell</code>. Using <code>nix-shell</code> allowed us
to debug, modify, and manually build software using an environment that
is almost identical to the one provided by <code>nix-build</code>.</p>
<p>Today, we will stop focusing on packaging and instead look at a critical
component of Nix: the garbage collector. When we use Nix tools, we are
often building derivations. This includes <code>.drv</code> files as well as out
paths. These artifacts go in the Nix store and take up space in our
storage. Eventually we may wish to free up some space by removing
derivations we no longer need. This is the focus of the 11th pill. By
default, Nix takes a relatively conservative approach when automatically
deciding which derivations are "needed". In this pill, we will also
see a technique to conduct more destructive upgrade and deletion
operations.</p>
<h2 id="how-does-garbage-collection-work"><a class="header" href="#how-does-garbage-collection-work">How does garbage collection work?</a></h2>
<p>Programming languages with garbage collectors use the concept of a set
of "garbage collector (or 'GC') roots" to keep track of "live"
objects. A GC root is an object that is always considered "live"
(unless explicitly removed as GC root). The garbage collection process
starts from the GC roots and proceeds by recursively marking object
references as "live". All other objects can be collected and deleted.</p>
<p>Instead of objects, Nix's garbage collection operates on store paths,
<a href="https://nixos.org/manual/nix/stable/package-management/garbage-collector-roots.html">with the GC roots themselves being store
paths</a>.
. This approach is much more principled than traditional package
managers such as <code>dpkg</code> or <code>rpm</code>, which may leave around unused packages
or dangling files.</p>
<p>The implementation is very simple and transparent to the user. The
primary GC roots are stored under <code>/nix/var/nix/gcroots</code>. If there is a
symlink to a store path, then the linked store path is a GC root.</p>
<p>Nix allows this directory to have subdirectories: it will simply
recursively traverse the subdirectories in search of symlinks to store
paths. When a symlink is encountered, its target is added to the list of
live store paths.</p>
<p>In summary, Nix maintains a list of GC roots. These roots can then be
used to compute a list of all live store paths. Any other store paths
are considered dead. Deleting these paths is now straightforward. Nix
first moves dead store paths to <code>/nix/store/trash</code>, which is an atomic
operation. Afterwards, the trash is emptied.</p>
<h2 id="playing-with-the-gc"><a class="header" href="#playing-with-the-gc">Playing with the GC</a></h2>
<p>Before we begin we first run the <a href="https://nixos.org/manual/nix/stable/command-ref/nix-collect-garbage.html">nix garbage
collector</a>
so that we have a clean setup for our experiments:</p>
<pre><code>$ nix-collect-garbage
finding garbage collector roots...
[...]
deleting unused links...
note: currently hard linking saves -0.00 MiB
1169 store paths deleted, 228.43 MiB freed
</code></pre>
<p>If we run the garbage collector again it won't find anything new to
delete, as we expect. After running the garbage collector, the nix store
only contains paths with references from the GC roots.</p>
<p>We now install a new program, <code>bsd-games</code>, inspect its store path, and
examine its GC root. The <code>nix-store -q --roots</code> command is used to query
the GC roots that refer to a given derivation. In this case, our current
user environment refers to <code>bsd-games</code>:</p>
<pre><code>$ nix-env -iA nixpkgs.bsdgames
$ readlink -f `which fortune`
/nix/store/b3lxx3d3ggxcggvjw5n0m1ya1gcrmbyn-bsd-games-2.17/bin/fortune
$ nix-store -q --roots `which fortune`
/nix/var/nix/profiles/default-9-link
$ nix-env --list-generations
[...]
   9   2014-08-20 12:44:14   (current)
</code></pre>
<p>Now we remove it and run the garbage collector, and note that
<code>bsd-games</code> is still in the nix store:</p>
<pre><code>$ nix-env -e bsd-games
uninstalling `bsd-games-2.17'
$ nix-collect-garbage
[...]
$ ls /nix/store/b3lxx3d3ggxcggvjw5n0m1ya1gcrmbyn-bsd-games-2.17
bin  share
</code></pre>
<p>The old generation is still in the nix store because it is a GC root. As
we will see below, all profiles and their generations are automatically
GC roots.</p>
<p>Removing a GC root is simple. In our case, we delete the generation that
refers to <code>bsd-games</code>, run the garbage collector, and note that
<code>bsd-games</code> is no longer in the nix store:</p>
<pre><code>$ rm /nix/var/nix/profiles/default-9-link
$ nix-env --list-generations
[...]
   8   2014-07-28 10:23:24
  10   2014-08-20 12:47:16   (current)
$ nix-collect-garbage
[...]
$ ls /nix/store/b3lxx3d3ggxcggvjw5n0m1ya1gcrmbyn-bsd-games-2.17
ls: cannot access /nix/store/b3lxx3d3ggxcggvjw5n0m1ya1gcrmbyn-bsd-games-2.17: No such file or directory
</code></pre>
<p>Note: <code>nix-env --list-generations</code> does not rely on any
particular metadata. It is able to list generations based solely on the
file names under the profiles directory.</p>
<p>Note that we removed the link from <code>/nix/var/nix/profiles</code>, not from
<code>/nix/var/nix/gcroots</code>. In addition to the latter, Nix treats
<code>/nix/var/nix/profiles</code> as a GC root. This is useful because it means
that any profile and its generations are GC roots. Other paths are
considered GC roots as well; for example, <code>/run/booted-system</code> on NixOS.
The command <code>nix-store --gc --print-roots</code> prints all paths considered
as GC roots when running the garbage collector.</p>
<h2 id="indirect-roots"><a class="header" href="#indirect-roots">Indirect roots</a></h2>
<p>Recall that building the GNU <code>hello</code> package with <code>nix-build</code> produces a
<code>result</code> symlink in the current directory. Despite the garbage
collection done above, the <code>hello</code> program is still working. Therefore,
it has not been garbage collected. Since there is no other derivation
that depends upon the GNU <code>hello</code> package, it must be a GC root.</p>
<p>In fact, <code>nix-build</code> automatically adds the <code>result</code> symlink as a GC
root. Note that this is not the built derivation, but the symlink
itself. These GC roots are added under <code>/nix/var/nix/gcroots/auto</code>.</p>
<pre><code>$ ls -l /nix/var/nix/gcroots/auto/
total 8
drwxr-xr-x 2 nix nix 4096 Aug 20 10:24 ./
drwxr-xr-x 3 nix nix 4096 Jul 24 10:38 ../
lrwxrwxrwx 1 nix nix   16 Jul 31 10:51 xlgz5x2ppa0m72z5qfc78b8wlciwvgiz -&gt; /home/nix/result/
</code></pre>
<p>The name of the GC root symlink is not important to us at this time.
What is important is that such a symlink exists and points to
<code>/home/nix/result</code>. This is called an <strong>indirect GC root</strong>. A GC root is
considered indirect if its specification is outside of
<code>/nix/var/nix/gcroots</code>. In this case, this means that the target of the
<code>result</code> symlink will not be garbage collected.</p>
<p>To remove a derivation considered "live" by an indirect GC root, there
are two possibilities:</p>
<ul>
<li>
<p>Remove the indirect GC root from <code>/nix/var/nix/gcroots/auto</code>.</p>
</li>
<li>
<p>Remove the <code>result</code> symlink.</p>
</li>
</ul>
<p>In the first case, the derivation will be deleted from the nix store
during garbage collection, and <code>result</code> becomes a dangling symlink. In
the second case, the derivation is removed as well as the indirect root
in <code>/nix/var/nix/gcroots/auto</code>.</p>
<p>Running <code>nix-collect-garbage</code> after deleting the GC root or the indirect
GC root will remove the derivation from the store.</p>
<h2 id="cleanup-everything"><a class="header" href="#cleanup-everything">Cleanup everything</a></h2>
<p>The main source of software duplication in the nix store comes from GC
roots, due to <code>nix-build</code> and profile generations. Running <code>nix-build</code>
results in a GC root for the build that refers to a specific version of
specific libraries, such as glibc. After an upgrade, we must delete the
previous build if we want the garbage collector to remove the
corresponding derivation, as well as if we want old dependencies cleaned
up.</p>
<p>The same holds for profiles. Manipulating the <code>nix-env</code> profile will
create further generations. Old generations refer to old software, thus
increasing duplication in the nix store after an upgrade.</p>
<p>Other systems typically "forget" everything about their previous state
after an upgrade. With Nix, we can perform this type of upgrade (having
Nix remove all old derivations, including old generations), but we do so
manually. There are four steps to doing this:</p>
<ul>
<li>
<p>First, we download a new version of the nixpkgs channel, which holds
the description of all the software. This is done via
<code>nix-channel --update</code>.</p>
</li>
<li>
<p>Then we upgrade our installed packages with <code>nix-env -u</code>. This will
bring us into a new generation with updated software.</p>
</li>
<li>
<p>Then we remove all the indirect roots generated by <code>nix-build</code>:
beware, as this will result in dangling symlinks. A smarter strategy
would also remove the target of those symlinks.</p>
</li>
<li>
<p>Finally, the <code>-d</code> option of <code>nix-collect-garbage</code> is used to delete
old generations of all profiles, then collect garbage. After this,
you lose the ability to rollback to any previous generation. It is
important to ensure the new generation is working well before
running this command.</p>
</li>
</ul>
<p>The four steps are shown below:</p>
<pre><code>$ nix-channel --update
$ nix-env -u --always
$ rm /nix/var/nix/gcroots/auto/*
$ nix-collect-garbage -d
</code></pre>
<h2 id="conclusion-7"><a class="header" href="#conclusion-7">Conclusion</a></h2>
<p>Garbage collection in Nix is a powerful mechanism to clean up your
system. The <code>nix-store</code> commands allow us to know why a certain
derivation is present in the nix store, and whether or not it is
eligible for garbage collection. We also saw how to conduct more
destructive deletion and upgrade operations.</p>
<h2 id="next-pill-10"><a class="header" href="#next-pill-10">Next pill</a></h2>
<p>In the next pill, we will package another project and introduce the
"inputs" design pattern. We've only played with a single derivation
until now; however we'd like to start organizing a small repository of
software. The "inputs" pattern is widely used in nixpkgs; it allows us
to decouple derivations from the repository itself and increase
customization opportunities.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inputs-design-pattern"><a class="header" href="#inputs-design-pattern">Package Repositories and the Inputs Design Pattern</a></h1>
<p>Welcome to the 12th Nix pill. In the previous <a href="11-garbage-collector.html">11th
pill</a>, we stopped packaging and cleaned up the
system with the garbage collector.</p>
<p>This time, we will resume packaging and improve different aspects of it.
We will also demonstrate how to create a repository of multiple
packages.</p>
<h2 id="repositories-in-nix"><a class="header" href="#repositories-in-nix">Repositories in Nix</a></h2>
<p>Package repositories in Nix arose naturally from the need to organize
packages. There is no preset directory structure or packaging policy
prescribed by Nix itself; Nix, as a full, functional programming
language, is powerful enough to support multiple different repository
formats.</p>
<p>Over time, the <code>nixpkgs</code> repository evolved a particular structure. This
structure reflects the history of Nix as well as the design patterns
adopted by its users as useful tools in building and organizing
packages. Below, we will examine some of these patterns in detail.</p>
<h2 id="the-single-repository-pattern"><a class="header" href="#the-single-repository-pattern">The single repository pattern</a></h2>
<p>Different operating system distributions have different opinions about
how package repositories should be organized. Systems like Debian
scatter packages in several small repositories (which tends to make
tracking interdependent changes more difficult, and hinders
contributions to the repositories), while systems like Gentoo put all
package descriptions in a single repository.</p>
<p>Nix follows the "single repository" pattern by placing all
descriptions of all packages into
<a href="https://github.com/NixOS/nixpkgs">nixpkgs</a>. This approach has proven
natural and attractive for new contributions.</p>
<p>For the rest of this pill, we will adopt the single repository pattern.
The natural implementation in Nix is to create a top-level Nix
expression, followed by one expression for each package. The top-level
expression imports and combines all package expressions in an attribute
set mapping names to packages.</p>
<p>In some programming languages, such an approach -- including every
possible package description in a single data structure -- would be
untenable due to the language needing to load the entire data structure
into memory before operating on it. Nix, however, is a lazy language and
only evaluates what is needed.</p>
<h2 id="packaging-graphviz"><a class="header" href="#packaging-graphviz">Packaging <code>graphviz</code></a></h2>
<p>We have already packaged GNU <code>hello</code>. Next, we will package a
graph-drawing program called <code>graphviz</code> so that we can create a
repository containing multiple packages. The <code>graphviz</code> package was
selected because it uses the standard autotools build system and
requires no patching. It also has optional dependencies, which will give
us an opportunity to illustrate a technique to configure builds to a
particular situation.</p>
<p>First, we download <code>graphviz</code> from
<a href="https://gitlab.com/api/v4/projects/4207231/packages/generic/graphviz-releases/2.49.3/graphviz-2.49.3.tar.gz">gitlab</a>.
The <code>graphviz.nix</code> expression is straightforward:</p>
<pre><code>let
  pkgs = import &lt;nixpkgs&gt; { };
  mkDerivation = import ./autotools.nix pkgs;
in
mkDerivation {
  name = "graphviz";
  src = ./graphviz-2.49.3.tar.gz;
}
</code></pre>
<p>If we build the project with <code>nix-build graphviz.nix</code>, we will get
runnable binaries under <code>result/bin</code>. Notice how we reused the same
<code>autotools.nix</code> of <code>hello.nix.</code></p>
<p>By default, <code>graphviz</code> does not compile with the ability to produce
<code>png</code> files. Thus, the derivation above will build a binary supporting
only the native output formats, as we see below:</p>
<pre><code>$ echo 'graph test { a -- b }'|result/bin/dot -Tpng -o test.png
Format: "png" not recognized. Use one of: canon cmap [...]
</code></pre>
<p>If we want to produce a <code>png</code> file with <code>graphviz</code>, we must add it to
our derivation. The place to do so is in <code>autotools.nix</code>, where we
created a <code>buildInputs</code> variable that gets concatenated to <code>baseInputs</code>.
This is the exact reason for this variable: to allow users of
<code>autotools.nix</code> to add additional inputs from package expressions.</p>
<p>Version 2.49 of <code>graphviz</code> has several plugins to output <code>png</code>. For
simplicity, we will use <code>libgd</code>.</p>
<h2 id="passing-library-information-to-pkg-config-via-environment-variables"><a class="header" href="#passing-library-information-to-pkg-config-via-environment-variables">Passing library information to <code>pkg-config</code> via environment variables</a></h2>
<p>The <code>graphviz</code> configuration script uses <code>pkg-config</code> to specify which
flags are passed to the compiler. Since there is no global location for
libraries, we need to tell <code>pkg-config</code> where to find its description
files, which tell the configuration script where to find headers and
libraries.</p>
<p>In classic POSIX systems, <code>pkg-config</code> just finds the <code>.pc</code> files of all
installed libraries in system folders like <code>/usr/lib/pkgconfig</code>.
However, these files are not present in the isolated environments
presented to Nix.</p>
<p>As an alternative, we can inform <code>pkg-config</code> about the location of
libraries via the <code>PKG_CONFIG_PATH</code> environment variable. We can
populate this environment variable using the same trick we used for
<code>PATH</code>: automatically filling the variables from <code>buildInputs</code>. This is
the relevant snippet of <code>setup.sh</code>:</p>
<pre><code>for p in $baseInputs $buildInputs; do
  if [ -d $p/bin ]; then
    export PATH="$p/bin${PATH:+:}$PATH"
  fi
  if [ -d $p/lib/pkgconfig ]; then
    export PKG_CONFIG_PATH="$p/lib/pkgconfig${PKG_CONFIG_PATH:+:}$PKG_CONFIG_PATH"
  fi
done
</code></pre>
<p>Now if we add derivations to <code>buildInputs</code>, their <code>lib/pkgconfig</code> and
<code>bin</code> paths are automatically added in <code>setup.sh</code>.</p>
<h2 id="completing-graphviz-with-gd"><a class="header" href="#completing-graphviz-with-gd">Completing graphviz with <code>gd</code></a></h2>
<p>Below, we finish the expression for <code>graphviz</code> with <code>gd</code> support. Note
the use of the <code>with</code> expression in <code>buildInputs</code> to avoid repeating
<code>pkgs</code>:</p>
<pre><code>let
  pkgs = import &lt;nixpkgs&gt; { };
  mkDerivation = import ./autotools.nix pkgs;
in
mkDerivation {
  name = "graphviz";
  src = ./graphviz-2.49.3.tar.gz;
  buildInputs = with pkgs; [
    pkg-config
    (pkgs.lib.getLib gd)
    (pkgs.lib.getDev gd)
  ];
}
</code></pre>
<p>We add <code>pkg-config</code> to the derivation to make this tool available for
the configure script. As <code>gd</code> is a package with <a href="https://nixos.org/manual/nixpkgs/stable/#sec-multiple-outputs-">split
outputs</a>,
we need to add both the library and development outputs.</p>
<p>After building, <code>graphviz</code> can now create <code>png</code>s.</p>
<h2 id="the-repository-expression"><a class="header" href="#the-repository-expression">The repository expression</a></h2>
<p>Now that we have two packages, we want to combine them into a single
repository. To do so, we'll mimic what <code>nixpkgs</code> does: we will create a
single attribute set containing derivations. This attribute set can then
be imported, and derivations can be selected by accessing the top-level
attribute set.</p>
<p>Using this technique we are able to abstract from the file names.
Instead of referring to a package by <code>REPO/some/sub/dir/package.nix</code>,
this technique allows us to select a derivation as
<code>importedRepo.package</code> (or <code>pkgs.package</code> in our examples).</p>
<p>To begin, create a default.nix in the current directory:</p>
<pre><code>{
  hello = import ./hello.nix;
  graphviz = import ./graphviz.nix;
}
</code></pre>
<p>This file is ready to use with <code>nix repl</code>:</p>
<pre><code>$ nix repl
nix-repl&gt; :l default.nix
Added 2 variables.
nix-repl&gt; hello
«derivation /nix/store/dkib02g54fpdqgpskswgp6m7bd7mgx89-hello.drv»
nix-repl&gt; graphviz
«derivation /nix/store/zqv520v9mk13is0w980c91z7q1vkhhil-graphviz.drv»
</code></pre>
<p>With <code>nix-build</code>, we can pass the -A option to access an attribute of
the set from the given <code>.nix</code> expression:</p>
<pre><code>$ nix-build default.nix -A hello
[...]
$ result/bin/hello
Hello, world!
</code></pre>
<p>The <code>default.nix</code> file is special. When a directory contains a
<code>default.nix</code> file, it is used as the implicit nix expression of the
directory. This, for example, allows us to run <code>nix-build -A hello</code>
without specifying <code>default.nix</code> explicitly.</p>
<p>We can now use <code>nix-env</code> to install the package into our user
environment:</p>
<pre><code>$ nix-env -f . -iA graphviz
[...]
$ dot -V
</code></pre>
<p>Taking a closer look at the above command, we see the following options:</p>
<ul>
<li>
<p>The -f option is used to specify the expression to use. In this
case, the expression is the <code>./default.nix</code> of the current
directory.</p>
</li>
<li>
<p>The -i option stands for "installation".</p>
</li>
<li>
<p>The -A is the same as above for <code>nix-build</code>.</p>
</li>
</ul>
<p>We reproduced the very basic behavior of <code>nixpkgs</code>: combining multiple
derivations into a single, top-level attribute set.</p>
<h2 id="the-inputs-pattern"><a class="header" href="#the-inputs-pattern">The inputs pattern</a></h2>
<p>The approach we've taken so far has a few problems:</p>
<ul>
<li>
<p>First, <code>hello.nix</code> and <code>graphviz.nix</code> are dependent on <code>nixpkgs</code>,
which they import directly. A better approach would be to pass in
<code>nixpkgs</code> as an argument, as we did in <code>autotools.nix</code>.</p>
</li>
<li>
<p>Second, we don't have a straightforward way to compile different
variants of the same software, such as <code>graphviz</code> with or without
<code>libgd</code> support.</p>
</li>
<li>
<p>Third, we don't have a way to test <code>graphviz</code> with a particular
<code>libgd</code> version.</p>
</li>
</ul>
<p>Until now, our approach to addressing the above problems has been
inadequate and required changing the nix expression to match our needs.
With the <code>inputs</code> pattern, we provide another answer: let the user
change the <code>inputs</code> of the expression.</p>
<p>When we talk about "the inputs of an expression", we are referring to
the set of derivations needed to build that expression. In this case:</p>
<ul>
<li>
<p><code>mkDerivation</code> from <code>autotools</code>. Recall that <code>mkDerivation</code> has an
implicit dependency on the toolchain.</p>
</li>
<li>
<p><code>libgd</code> and its dependencies.</p>
</li>
</ul>
<p>The <code>./src</code> directory is also an input, but we wouldn't change the
source from the caller. In <code>nixpkgs</code> we prefer to write another
expression for version bumps (e.g. because patches or different inputs
are needed).</p>
<p>Our goal is to make package expressions independent of the repository.
To achieve this, we use functions to declare inputs for a derivation.
For example, with <code>graphviz.nix</code>, we make the following changes to make
the derivation independent of the repository and customizable:</p>
<pre><code>{ mkDerivation, lib, gdSupport ? true, gd, pkg-config }:

mkDerivation {
  name = "graphviz";
  src = ./graphviz-2.49.3.tar.gz;
  buildInputs =
    if gdSupport
      then [
          pkg-config
          (lib.getLib gd)
          (lib.getDev gd)
        ]
      else [];
}
</code></pre>
<p>Recall that "<code>{...}: ...</code>" is the syntax for defining functions
accepting an attribute set as argument; the above snippet just defines a
function.</p>
<p>We made <code>gd</code> and its dependencies optional. If <code>gdSupport</code> is true
(which it is by default), we will fill <code>buildInputs</code> and <code>graphviz</code> will
be built with <code>gd</code> support. Otherwise, if an attribute set is passed
with <code>gdSupport = false;</code>, the build will be completed without <code>gd</code>
support.</p>
<p>Going back to back to <code>default.nix</code>, we modify our expression to utilize
the inputs pattern:</p>
<pre><code>let
  pkgs = import &lt;nixpkgs&gt; { };
  mkDerivation = import ./autotools.nix pkgs;
in
with pkgs;
{
  hello = import ./hello.nix { inherit mkDerivation; };
  graphviz = import ./graphviz.nix {
    inherit
      mkDerivation
      lib
      gd
      pkg-config
      ;
  };
  graphvizCore = import ./graphviz.nix {
    inherit
      mkDerivation
      lib
      gd
      pkg-config
      ;
    gdSupport = false;
  };
}
</code></pre>
<p>We factorized the import of <code>nixpkgs</code> and <code>mkDerivation</code>, and also added
a variant of <code>graphviz</code> with <code>gd</code> support disabled. The result is that
both <code>hello.nix</code> (left as an exercise for the reader) and <code>graphviz.nix</code>
are independent of the repository and customizable by passing specific
inputs.</p>
<p>If we wanted to build <code>graphviz</code> with a specific version of <code>gd</code>, it
would suffice to pass <code>gd = ...;</code>.</p>
<p>If we wanted to change the toolchain, we would simply pass a different
<code>mkDerivation</code> function.</p>
<p>Let's talk a closer look at the snippet and dissect the syntax:</p>
<ul>
<li>
<p>The entire expression in <code>default.nix</code> returns an attribute set with
the keys <code>hello</code>, <code>graphviz</code>, and <code>graphvizCore</code>.</p>
</li>
<li>
<p>With "<code>let</code>", we define some local variables.</p>
</li>
<li>
<p>We bring <code>pkgs</code> into the scope when defining the package set. This
saves us from having to type <code>pkgs</code>" repeatedly.</p>
</li>
<li>
<p>We import <code>hello.nix</code> and <code>graphviz.nix</code>, which each return a
function. We call the functions with a set of inputs to get back the
derivation.</p>
</li>
<li>
<p>The "<code>inherit x</code>" syntax is equivalent to "<code>x = x</code>". This means
that the "<code>inherit gd</code>" here, combined with the above
"<code>with pkgs;</code>", is equivalent to "<code>gd = pkgs.gd</code>".</p>
</li>
</ul>
<p>The entire repository of this can be found at the <a href="https://gist.github.com/tfc/ca800a444b029e85a14e530c25f8e872">pill
12</a> gist.</p>
<h2 id="conclusion-8"><a class="header" href="#conclusion-8">Conclusion</a></h2>
<p>The "<code>inputs</code>" pattern allows our expressions to be easily
customizable through a set of arguments. These arguments could be flags,
derivations, or any other customizations enabled by the nix language.
Our package expressions are simply functions: there is no extra magic
present.</p>
<p>The "<code>inputs</code>" pattern also makes the expressions independent of the
repository. Given that we pass all needed information through arguments,
it is possible to use these expressions in any other context.</p>
<h2 id="next-pill-11"><a class="header" href="#next-pill-11">Next pill</a></h2>
<p>In the next pill, we will talk about the "<code>callPackage</code>" design
pattern. This removes the tedium of specifying the names of the inputs
twice: once in the top-level <code>default.nix</code>, and once in the package
expression. With <code>callPackage</code>, we will implicitly pass the necessary
inputs from the top-level expression.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="callpackage-design-pattern"><a class="header" href="#callpackage-design-pattern">Callpackage Design Pattern</a></h1>
<p>Welcome to the 13th Nix pill. In the previous <a href="12-inputs-design-pattern.html">12th
pill</a>, we introduced the first basic design
pattern for organizing a repository of software. In addition, we
packaged graphviz so that we had two packages to bundle into an example
repository.</p>
<p>The next design pattern we will examine is called the <code>callPackage</code>
pattern. This technique is extensively used in
<a href="https://github.com/NixOS/nixpkgs">nixpkgs</a>, and it's the current de
facto standard for importing packages in a repository. Its purpose is to
reduce the duplication of identifiers between package derivation inputs
and repository derivations.</p>
<h2 id="the-callpackage-convenience"><a class="header" href="#the-callpackage-convenience">The callPackage convenience</a></h2>
<p>In the previous pill, we demonstrated how the <code>inputs</code> pattern decouples
packages from the repository. This allowed us to manually pass the
inputs to the derivation; the derivation declares its inputs, and the
caller passes the arguments.</p>
<p>However, as with usual programming languages, there is some duplication
of work: we declare parameter names and then we pass arguments,
typically with the same name. For example, if we define a package
derivation using the <code>inputs</code> pattern such as:</p>
<pre><code>{ input1, input2, ... }:
...
</code></pre>
<p>we would likely want to bundle that package derivation into a repository
via a an attribute set defined as something like:</p>
<pre><code>rec {
  lib1 = import package1.nix { inherit input1 input2; };
  program2 = import package2.nix { inherit inputX inputY lib1; };
}
</code></pre>
<p>There are two things to note. First, that inputs often have the same
name as attributes in the repository itself. Second, that (due to the
<code>rec</code> keyword), the inputs to a package derivation may be other packages
in the repository itself.</p>
<p>Rather than passing the inputs twice, we would prefer to pass those
inputs from the repository automatically and allow for manually
overriding defaults.</p>
<p>To achieve this, we will define a <code>callPackage</code> function with the
following calling convention:</p>
<pre><code>{
  lib1 = callPackage package1.nix { };
  program2 = callPackage package2.nix { someoverride = overriddenDerivation; };
}
</code></pre>
<p>We want <code>callPackage</code> to be a function of two arguments, with the
following behavior:</p>
<ul>
<li>
<p>Import the given expression contained in the file of the first
argument, and return a function. This function returns a package
derivation that uses the inputs pattern.</p>
</li>
<li>
<p>Determine the name of the arguments to the function (i.e., the names
of the inputs to the package derivation).</p>
</li>
<li>
<p>Pass default arguments from the repository set, and let us override
those arguments if we wish to customize the package derivation.</p>
</li>
</ul>
<h2 id="implementing-callpackage"><a class="header" href="#implementing-callpackage">Implementing <code>callPackage</code></a></h2>
<p>In this section, we will build up the <code>callPackages</code> pattern from
scratch. To start, we need a way to obtain the argument names of a
function (in this case, the function that takes "inputs" and produces
a package derivation) at runtime. This is because we want to
automatically pass such arguments.</p>
<p>Nix provides a builtin function to do this:</p>
<pre><code>nix-repl&gt; add = { a ? 3, b }: a+b
nix-repl&gt; builtins.functionArgs add
{ a = true; b = false; }
</code></pre>
<p>In addition to returning the argument names, the attribute set returned
by <code>functionArgs</code> indicates whether or not the argument has a default
value. For our purposes, we are only interested in the argument names;
we do not care about the default values right now.</p>
<p>The next step is to make <code>callPackage</code> automatically pass inputs to our
package derivations based on the argument names we've just obtained
with <code>functionArgs</code>.</p>
<p>To do this, we need two things:</p>
<ul>
<li>
<p>A package repository set containing package derivations that match
the arguments names we've obtained</p>
</li>
<li>
<p>A way to obtain an auto-populated attribute set combining the
package repository and the return value of <code>functionArgs</code>.</p>
</li>
</ul>
<p>The former is easy: we just have to set our package derivation's inputs
to be package names in a repository, such as <code>nixpkgs</code>. For the latter,
Nix provides another builtin function:</p>
<pre><code>nix-repl&gt; values = { a = 3; b = 5; c = 10; }
nix-repl&gt; builtins.intersectAttrs values (builtins.functionArgs add)
{ a = true; b = false; }
nix-repl&gt; builtins.intersectAttrs (builtins.functionArgs add) values
{ a = 3; b = 5; }
</code></pre>
<p>The <code>intersectAttrs</code> returns an attribute set whose names are the
intersection of both arguments' attribute names, with the attribute
values taken from the second argument.</p>
<p>This is all we need to do: we have obtained the argument names from a
function, and populated these with an existing set of attributes. This
is our simple implementation of <code>callPackage</code>:</p>
<pre><code>nix-repl&gt; callPackage = set: f: f (builtins.intersectAttrs (builtins.functionArgs f) set)
nix-repl&gt; callPackage values add
8
nix-repl&gt; with values; add { inherit a b; }
8
</code></pre>
<p>Let's dissect the above snippet:</p>
<ul>
<li>
<p>We define a <code>callPackage</code> variable which is a function.</p>
</li>
<li>
<p>The first parameter to the <code>callPackage</code> function is a set of
name-value pairs that may appear in the argument set of the function
we wish to "autocall".</p>
</li>
<li>
<p>The second parameter is the function to "autocall"</p>
</li>
<li>
<p>We take the argument names of the function and intersect with the
set of all values.</p>
</li>
<li>
<p>Finally, we call the passed function <code>f</code> with the resulting
intersection.</p>
</li>
</ul>
<p>In the snippet above, we've also demonstrated that the <code>callPackage</code>
call is equivalent to directly calling <code>add a b</code>.</p>
<p>We achieved most of what we wanted: to automatically call functions
given a set of possible arguments. If an argument is not found within
the set we used to call the function, then we receive an error (unless
the function has variadic arguments denoted with <code>...</code>, as explained in
the <a href="05-functions-and-imports.html">5th pill</a>).</p>
<p>The last missing piece is allowing users to override some of the
parameters. We may not want to always call functions with values taken
from the big set. Thus, we add a third parameter which takes a set of
overrides:</p>
<pre><code>nix-repl&gt; callPackage = set: f: overrides: f ((builtins.intersectAttrs (builtins.functionArgs f) set) // overrides)
nix-repl&gt; callPackage values add { }
8
nix-repl&gt; callPackage values add { b = 12; }
15
</code></pre>
<p>Apart from the increasing number of parentheses, it should be clear that
we simply take a set union between the default arguments and the
overriding set.</p>
<h2 id="using-callpackage-to-simplify-the-repository"><a class="header" href="#using-callpackage-to-simplify-the-repository">Using callPackage to simplify the repository</a></h2>
<p>Given our <code>callPackages</code>, we can simplify the repository expression in
<code>default.nix</code>:</p>
<pre><code>let
  nixpkgs = import &lt;nixpkgs&gt; { };
  allPkgs = nixpkgs // pkgs;
  callPackage =
    path: overrides:
    let
      f = import path;
    in
    f ((builtins.intersectAttrs (builtins.functionArgs f) allPkgs) // overrides);
  pkgs = with nixpkgs; {
    mkDerivation = import ./autotools.nix nixpkgs;
    hello = callPackage ./hello.nix { };
    graphviz = callPackage ./graphviz.nix { };
    graphvizCore = callPackage ./graphviz.nix { gdSupport = false; };
  };
in
pkgs
</code></pre>
<p>Let's examine this in detail:</p>
<ul>
<li>
<p>The expression above defines our own package repository, which we
call <code>pkgs</code>, that contains <code>hello</code> along with our two variants of
<code>graphviz</code>.</p>
</li>
<li>
<p>In the <code>let</code> expression, we import <code>nixpkgs</code>. Note that previously,
we referred to this import with the variable <code>pkgs</code>, but now that
name is taken by the repository we are creating ourselves.</p>
</li>
<li>
<p>We needed a way to pass <code>pkgs</code> to <code>callPackage</code> somehow. Instead of
returning the set of packages directly from <code>default.nix</code>, we first
assign it to a <code>let</code> variable and reuse it in <code>callPackage</code>.</p>
</li>
<li>
<p>For convenience, in <code>callPackage</code> we first import the file instead
of calling it directly. Otherwise we would have to write the
<code>import</code> for each package.</p>
</li>
<li>
<p>Since our expressions use packages from <code>nixpkgs</code>, in <code>callPackage</code>
we use <code>allPkgs</code>, which is the union of <code>nixpkgs</code> and our packages.</p>
</li>
<li>
<p>We moved <code>mkDerivation</code> into <code>pkgs</code> itself, so that it also gets
passed automatically.</p>
</li>
</ul>
<p>Note how easily we overrode arguments in the case of <code>graphviz</code> without
<code>gd</code>. In addition, note how easy it was to merge two repositories:
<code>nixpkgs</code> and our <code>pkgs</code>!</p>
<p>The reader should notice a magic thing happening. We're defining <code>pkgs</code>
in terms of <code>callPackage</code>, and <code>callPackage</code> in terms of <code>pkgs</code>. That
magic is possible thanks to lazy evaluation: <code>builtins.intersectAttrs</code>
doesn't need to know the values in <code>allPkgs</code> in order to perform
intersection, only the keys that do not require <code>callPackage</code>
evaluation.</p>
<h2 id="conclusion-9"><a class="header" href="#conclusion-9">Conclusion</a></h2>
<p>The "<code>callPackage</code>" pattern has simplified our repository
considerably. We were able to import packages that require named
arguments and call them automatically, given the set of all packages
sourced from <code>nixpkgs</code>.</p>
<p>We've also introduced some useful builtin functions that allows us to
introspect Nix functions and manipulate attributes. These builtin
functions are not usually used when packaging software, but rather act
as tools for packaging. They are documented in the <a href="https://nixos.org/manual/nix/stable/expressions/builtins.html">Nix
manual</a>.</p>
<p>Writing a repository in Nix is an evolution of writing convenient
functions for combining the packages. This pill demonstrates how Nix can
be a generic tool to build and deploy software, and how suitable it is
to create software repositories with our own conventions.</p>
<h2 id="next-pill-12"><a class="header" href="#next-pill-12">Next pill</a></h2>
<p>In the next pill, we will talk about the "<code>override</code>" design pattern.
The <code>graphvizCore</code> seems straightforward. It starts from <code>graphviz.nix</code>
and builds it without gd. In the next pill, we will consider another
point of view: starting from <code>pkgs.graphviz</code> and disabling gd?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="override-design-pattern"><a class="header" href="#override-design-pattern">Override Design Pattern</a></h1>
<p>Welcome to the 14th Nix pill. In the previous
<a href="13-callpackage-design-pattern.html">13th</a> pill, we introduced the
<code>callPackage</code> pattern and used it to simplify the composition of
software in a repository.</p>
<p>The next design pattern is less necessary, but is useful in many cases
and is a good exercise to learn more about Nix.</p>
<h2 id="about-composability"><a class="header" href="#about-composability">About composability</a></h2>
<p>Functional languages are known for being able to compose functions. In
particular, these languages gain expressivity from functions that
manipulate an original value into a new value having the same structure.
This allows us to compose multiple functions to perform the desired
modifications.</p>
<p>In Nix, we mostly talk about <strong>functions</strong> that accept inputs in order
to return <strong>derivations</strong>. In our world, we want utility functions that
are able to manipulate those structures. These utilities add some useful
properties to the original value, and we'd like to be able to apply
more utilities on top of the result.</p>
<p>For example, let's say we have an initial derivation <code>drv</code> and we want
to transform it into a <code>drv</code> with debugging information and custom
patches:</p>
<pre><code>debugVersion (applyPatches [ ./patch1.patch ./patch2.patch ] drv)
</code></pre>
<p>The final result should be the original derivation with some changes.
This is both interesting and very different from other packaging
approaches, which is a consequence of using a functional language to
describe packages.</p>
<p>Designing such utilities is not trivial in a functional language without
static typing, because understanding what can or cannot be composed is
difficult. But we try to do our best.</p>
<h2 id="the-override-pattern"><a class="header" href="#the-override-pattern">The override pattern</a></h2>
<p>In <a href="12-inputs-design-pattern.html">pill 12</a> we introduced the inputs design
pattern. We do not return a derivation picking dependencies directly
from the repository; rather we declare the inputs and let the callers
pass the necessary arguments.</p>
<p>In our repository we have a set of attributes that import the
expressions of the packages and pass these arguments, getting back a
derivation. Let's take for example the graphviz attribute:</p>
<pre><code>graphviz = import ./graphviz.nix { inherit mkDerivation gd fontconfig libjpeg bzip2; };
</code></pre>
<p>If we wanted to produce a derivation of graphviz with a customized gd
version, we would have to repeat most of the above plus specifying an
alternative gd:</p>
<pre><code>{
  mygraphviz = import ./graphviz.nix {
    inherit
      mkDerivation
      fontconfig
      libjpeg
      bzip2
      ;
    gd = customgd;
  };
}
</code></pre>
<p>That's hard to maintain. Using <code>callPackage</code> would be easier:</p>
<pre><code>mygraphviz = callPackage ./graphviz.nix { gd = customgd; };
</code></pre>
<p>But we may still be diverging from the original graphviz in the
repository.</p>
<p>We would like to avoid specifying the nix expression again. Instead, we
would like to reuse the original graphviz attribute in the repository
and add our overrides like so:</p>
<pre><code>mygraphviz = graphviz.override { gd = customgd; };
</code></pre>
<p>The difference is obvious, as well as the advantages of this approach.</p>
<p>Note: that <code>.override</code> is not a "method" in the OO sense
as you may think. Nix is a functional language. The<code>.override</code> is simply
an attribute of a set.</p>
<h2 id="the-override-implementation"><a class="header" href="#the-override-implementation">The override implementation</a></h2>
<p>Recall that the graphviz attribute in the repository is the derivation
returned by the function imported from <code>graphviz.nix</code>. We would like to
add a further attribute named "<code>override</code>" to the returned set.</p>
<p>Let's start by first creating a function "<code>makeOverridable</code>". This
function will take two arguments: a function (that must return a set)
and the set of original arguments to be passed to the function.</p>
<p>We will put this function in a <code>lib.nix</code>:</p>
<pre><code>{
  makeOverridable =
    f: origArgs:
    let
      origRes = f origArgs;
    in
    origRes // { override = newArgs: f (origArgs // newArgs); };
}
</code></pre>
<p><code>makeOverridable</code> takes a function and a set of original arguments. It
returns the original returned set, plus a new <code>override</code> attribute.</p>
<p>This <code>override</code> attribute is a function taking a set of new arguments,
and returns the result of the original function called with the original
arguments unified with the new arguments. This is admittedly somewhat
confusing, but the examples below should make it clear.</p>
<p>Let's try it with <code>nix repl</code>:</p>
<pre><code>$ nix repl
nix-repl&gt; :l lib.nix
Added 1 variables.
nix-repl&gt; f = { a, b }: { result = a+b; }
nix-repl&gt; f { a = 3; b = 5; }
{ result = 8; }
nix-repl&gt; res = makeOverridable f { a = 3; b = 5; }
nix-repl&gt; res
{ override = «lambda»; result = 8; }
nix-repl&gt; res.override { a = 10; }
{ result = 15; }
</code></pre>
<p>Note that, as we specified above, the function <code>f</code> does not return the
plain sum. Instead, it returns a set with the sum bound to the name
<code>result</code>.</p>
<p>The variable <code>res</code> contains the result of the function call without any
override. It's easy to see in the definition of <code>makeOverridable</code>. In
addition, you can see that the new <code>override</code> attribute is a function.</p>
<p>Calling <code>res.override</code> with a set will invoke the original function with
the overrides, as expected.</p>
<p>This is a good start, but we can't override again! This is because the
returned set (with <code>result = 15</code>) does not have an <code>override</code> attribute
of its own. This is bad; it breaks further composition.</p>
<p>The solution is simple: the <code>.override</code> function should make the result
overridable again:</p>
<pre><code>rec {
  makeOverridable =
    f: origArgs:
    let
      origRes = f origArgs;
    in
    origRes // { override = newArgs: makeOverridable f (origArgs // newArgs); };
}
</code></pre>
<p>Please note the <code>rec</code> keyword. It's necessary so that we can refer to
<code>makeOverridable</code> from <code>makeOverridable</code> itself.</p>
<p>Now let's try overriding twice:</p>
<pre><code>nix-repl&gt; :l lib.nix
Added 1 variables.
nix-repl&gt; f = { a, b }: { result = a+b; }
nix-repl&gt; res = makeOverridable f { a = 3; b = 5; }
nix-repl&gt; res2 = res.override { a = 10; }
nix-repl&gt; res2
{ override = «lambda»; result = 15; }
nix-repl&gt; res2.override { b = 20; }
{ override = «lambda»; result = 30; }
</code></pre>
<p>Success! The result is 30 (as expected) because <code>a</code> is overridden to 10
in the first override, and <code>b</code> is overridden to 20 in the second.</p>
<p>Now it would be nice if <code>callPackage</code> made our derivations overridable.
This is an exercise for the reader.</p>
<h2 id="conclusion-10"><a class="header" href="#conclusion-10">Conclusion</a></h2>
<p>The "<code>override</code>" pattern simplifies the way we customize packages
starting from an existing set of packages. This opens a world of
possibilities for using a central repository like <code>nixpkgs</code> and defining
overrides on our local machine without modifying the original package.</p>
<p>We can dream of a custom, isolated <code>nix-shell</code> environment for testing
graphviz with a custom gd:</p>
<pre><code>debugVersion (graphviz.override { gd = customgd; })
</code></pre>
<p>Once a new version of the overridden package comes out in the
repository, the customized package will make use of it automatically.</p>
<p>The key in Nix is to find powerful yet simple abstractions in order to
let the user customize their environment with highest consistency and
lowest maintenance time, by using predefined composable components.</p>
<h2 id="next-pill-13"><a class="header" href="#next-pill-13">Next pill</a></h2>
<p>In the next pill, we will talk about Nix search paths. By "search
path", we mean a place in the file system where Nix looks for
expressions. This answers the question of where <code>&lt;nixpkgs&gt;</code> comes from.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nix-search-paths"><a class="header" href="#nix-search-paths">Nix Search Paths</a></h1>
<p>Welcome to the 15th Nix pill. In the previous
<a href="14-override-design-pattern.html">14th</a> pill we have introduced the
"override" pattern, useful for writing variants of derivations by
passing different inputs.</p>
<p>Assuming you followed the previous posts, I hope you are now ready to
understand <code>nixpkgs</code>. But we have to find <code>nixpkgs</code> in our system first!
So this is the step: introducing some options and environment variables
used by nix tools.</p>
<h2 id="the-nix_path"><a class="header" href="#the-nix_path">The NIX_PATH</a></h2>
<p>The <a href="https://nixos.org/manual/nix/stable/command-ref/env-common.html">NIX_PATH environment
variable</a>
is very important. It's very similar to the <code>PATH</code> environment
variable. The syntax is similar, several paths are separated by a colon
<code>:</code>. Nix will then search for something in those paths from left to
right.</p>
<p>Who uses <code>NIX_PATH</code>? The nix expressions! Yes, <code>NIX_PATH</code> is not of much
use by the nix tools themselves, rather it's used when writing nix
expressions.</p>
<p>In the shell for example, when you execute the command <code>ping</code>, it's
being searched in the <code>PATH</code> directories. The first one found is the one
being used.</p>
<p>In nix it's exactly the same, however the syntax is different. Instead
of just typing <code>ping</code> you have to type <code>&lt;ping&gt;</code>. Yes, I know... you are
already thinking of <code>&lt;nixpkgs&gt;</code>. However, don't stop reading here,
let's keep going.</p>
<p>What's <code>NIX_PATH</code> good for? Nix expressions may refer to an
"abstract" path such as <code>&lt;nixpkgs&gt;</code>, and it's possible to override it
from the command line.</p>
<p>For ease we will use <code>nix-instantiate --eval</code> to do our tests. I remind
you,
<a href="https://nixos.org/manual/nix/stable/command-ref/nix-instantiate.html">nix-instantiate</a>
is used to evaluate nix expressions and generate the .drv files. Here we
are not interested in building derivations, so evaluation is enough. It
can be used for one-shot expressions.</p>
<h2 id="fake-it-a-little"><a class="header" href="#fake-it-a-little">Fake it a little</a></h2>
<p>It's useless from a nix view point, but I think it's useful for your
own understanding. Let's use <code>PATH</code> itself as <code>NIX_PATH</code>, and try to
locate <code>ping</code> (or another binary if you don't have it).</p>
<pre><code>$ nix-instantiate --eval -E '&lt;ping&gt;'
error: file `ping' was not found in the Nix search path (add it using $NIX_PATH or -I)
$ NIX_PATH=$PATH nix-instantiate --eval -E '&lt;ping&gt;'
/bin/ping
$ nix-instantiate -I /bin --eval -E '&lt;ping&gt;'
/bin/ping
</code></pre>
<p>Great. At first attempt nix obviously said could not be found anywhere
in the search path. Note that the -I option accepts a single directory.
Paths added with -I take precedence over <code>NIX_PATH</code>.</p>
<p>The <code>NIX_PATH</code> also accepts a different yet very handy syntax:
"<code>somename=somepath</code>". That is, instead of searching inside a
directory for a name, we specify exactly the value of that name.</p>
<pre><code>$ NIX_PATH="ping=/bin/ping" nix-instantiate --eval -E '&lt;ping&gt;'
/bin/ping
$ NIX_PATH="ping=/bin/foo" nix-instantiate --eval -E '&lt;ping&gt;'
error: file `ping' was not found in the Nix search path (add it using $N
</code></pre>
<p>Note in the second case how Nix checks whether the path exists or not.</p>
<h2 id="the-path-to-repository"><a class="header" href="#the-path-to-repository">The path to repository</a></h2>
<p>You are out of curiosity, right?</p>
<pre><code>$ nix-instantiate --eval -E '&lt;nixpkgs&gt;'
/home/nix/.nix-defexpr/channels/nixpkgs
$ echo $NIX_PATH
nixpkgs=/home/nix/.nix-defexpr/channels/nixpkgs
</code></pre>
<p>You may have a different path, depending on how you added channels etc..
Anyway that's the whole point. The <code>&lt;nixpkgs&gt;</code> stranger that we used in
our nix expressions, is referring to a path in the filesystem specified
by <code>NIX_PATH</code>.</p>
<p>You can list that directory and realize it's simply a checkout of the
nixpkgs repository at a specific commit (hint: <code>.version-suffix</code>).</p>
<p>The <code>NIX_PATH</code> variable is exported by <code>nix.sh</code>, and that's the reason
why I always asked you to <a href="https://nixos.org/manual/nix/stable/installation/env-variables.html">source
nix.sh</a>
at the beginning of my posts.</p>
<p>You may wonder: then I can also specify a different
<a href="https://github.com/NixOS/nixpkgs">nixpkgs</a> path to, e.g., a
<code>git checkout</code> of <code>nixpkgs</code>? Yes, you can and I encourage doing that.
We'll talk about this in the next pill.</p>
<p>Let's define a path for our repository, then! Let's say all the
<code>default.nix</code>, <code>graphviz.nix</code> etc. are under <code>/home/nix/mypkgs</code>:</p>
<pre><code>$ export NIX_PATH=mypkgs=/home/nix/mypkgs:$NIX_PATH
$ nix-instantiate --eval '&lt;mypkgs&gt;'
{ graphviz = &lt;code&gt;; graphvizCore = &lt;code&gt;; hello = &lt;code&gt;; mkDerivation = &lt;code&gt;; }
</code></pre>
<p>Yes, <code>nix-build</code> also accepts paths with angular brackets. We first
evaluate the whole repository (<code>default.nix</code>) and then pick the graphviz
attribute.</p>
<h2 id="a-big-word-about-nix-env"><a class="header" href="#a-big-word-about-nix-env">A big word about nix-env</a></h2>
<p>The
<a href="https://nixos.org/manual/nix/stable/command-ref/nix-env.html">nix-env</a>
command is a little different than <code>nix-instantiate</code> and <code>nix-build</code>.
Whereas <code>nix-instantiate</code> and <code>nix-build</code> require a starting nix
expression, <code>nix-env</code> does not.</p>
<p>You may be crippled by this concept at the beginning, you may think
<code>nix-env</code> uses <code>NIX_PATH</code> to find the <code>nixpkgs</code> repository. But that's
not it.</p>
<p>The <code>nix-env</code> command uses <code>~/.nix-defexpr</code>, which is also part of
<code>NIX_PATH</code> by default, but that's only a coincidence. If you empty
<code>NIX_PATH</code>, <code>nix-env</code> will still be able to find derivations because of
<code>~/.nix-defexpr</code>.</p>
<p>So if you run <code>nix-env -i graphviz</code> inside your repository, it will
install the nixpkgs one. Same if you set <code>NIX_PATH</code> to point to your
repository.</p>
<p>In order to specify an alternative to <code>~/.nix-defexpr</code> it's possible to
use the -f option:</p>
<pre><code>$ nix-env -f '&lt;mypkgs&gt;' -i graphviz
warning: there are multiple derivations named `graphviz'; using the first one
replacing old `graphviz'
installing `graphviz'
</code></pre>
<p>Oh why did it say there's another derivation named graphviz? Because
both <code>graphviz</code> and <code>graphvizCore</code> attributes in our repository have the
name "graphviz" for the derivation:</p>
<pre><code>$ nix-env -f '&lt;mypkgs&gt;' -qaP
graphviz      graphviz
graphvizCore  graphviz
hello         hello
</code></pre>
<p>By default <code>nix-env</code> parses all derivations and uses the derivation
names to interpret the command line. So in this case "graphviz"
matched two derivations. Alternatively, like for <code>nix-build</code>, one can
use -A to specify an attribute name instead of a derivation name:</p>
<pre><code>$ nix-env -f '&lt;mypkgs&gt;' -i -A graphviz
replacing old `graphviz'
installing `graphviz'
</code></pre>
<p>This form, other than being more precise, it's also faster because
<code>nix-env</code> does not have to parse all the derivations.</p>
<p>For completeness: you must install <code>graphvizCore</code> with -A, since without
the -A switch it's ambiguous.</p>
<p>In summary, it may happen when playing with nix that <code>nix-env</code> picks a
different derivation than <code>nix-build</code>. In that case you probably
specified <code>NIX_PATH</code>, but <code>nix-env</code> is instead looking into
<code>~/.nix-defexpr</code>.</p>
<p>Why is <code>nix-env</code> having this different behavior? I don't know
specifically by myself either, but the answers could be:</p>
<ul>
<li>
<p><code>nix-env</code> tries to be generic, thus it does not look for <code>nixpkgs</code>
in <code>NIX_PATH</code>, rather it looks in <code>~/.nix-defexpr</code>.</p>
</li>
<li>
<p><code>nix-env</code> is able to merge multiple trees in <code>~/.nix-defexpr</code> by
looking at all the possible derivations</p>
</li>
</ul>
<p>It may also happen to you <strong>that you cannot match a derivation name when
installing</strong>, because of the derivation name vs -A switch described
above. Maybe <code>nix-env</code> wanted to be more friendly in this case for
default user setups.</p>
<p>It may or may not make sense for you, or it's like that for historical
reasons, but that's how it works currently, unless somebody comes up
with a better idea.</p>
<h2 id="conclusion-11"><a class="header" href="#conclusion-11">Conclusion</a></h2>
<p>The <code>NIX_PATH</code> variable is the search path used by nix when using the
angular brackets syntax. It's possible to refer to "abstract" paths
inside nix expressions and define the "concrete" path by means of
<code>NIX_PATH</code>, or the usual -I flag in nix tools.</p>
<p>We've also explained some of the uncommon <code>nix-env</code> behaviors for
newcomers. The <code>nix-env</code> tool does not use <code>NIX_PATH</code> to search for
packages, but rather for <code>~/.nix-defexpr</code>. Beware of that!</p>
<p>In general do not abuse <code>NIX_PATH</code>, when possible use relative paths
when writing your own nix expressions. Of course, in the case of
<code>&lt;nixpkgs&gt;</code> in our repository, that's a perfectly fine usage of
<code>NIX_PATH</code>. Instead, inside our repository itself, refer to expressions
with relative paths like <code>./hello.nix</code>.</p>
<h2 id="next-pill-14"><a class="header" href="#next-pill-14">Next pill</a></h2>
<p>...we will finally dive into <code>nixpkgs</code>. Most of the techniques we have
developed in this series are already in <code>nixpkgs</code>, like <code>mkDerivation</code>,
<code>callPackage</code>, <code>override</code>, etc., but of course better. With time, those
base utilities get enhanced by the community with more features in order
to handle more and more use cases and in a more general way.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nixpkgs-parameters"><a class="header" href="#nixpkgs-parameters">Nixpkgs Parameters</a></h1>
<p>Welcome to the 16th Nix pill. In the previous <a href="15-nix-search-paths.html">15th</a>
pill we've realized how nix finds expressions with the angular brackets
syntax, so that we finally know where <code>&lt;nixpkgs&gt;</code> is located on our
system.</p>
<p>We can start diving into the <a href="https://github.com/NixOS/nixpkgs">nixpkgs
repository</a>, through all the various
tools and design patterns. Please note that also <code>nixpkgs</code> has its own
manual, underlying the difference between the general <code>nix</code> language and
the <code>nixpkgs</code> repository.</p>
<h2 id="the-defaultnix-expression"><a class="header" href="#the-defaultnix-expression">The default.nix expression</a></h2>
<p>We will not start inspecting packages at the beginning, rather the
general structure of <code>nixpkgs</code>.</p>
<p>In our custom repository we created a <code>default.nix</code> which composed the
expressions of the various packages.</p>
<p>Also <code>nixpkgs</code> has its own
<a href="https://github.com/NixOS/nixpkgs/blob/master/default.nix">default.nix</a>,
which is the one being loaded when referring to <code>&lt;nixpkgs&gt;</code>. It does a
simple thing: check whether the <code>nix</code> version is at least 1.7 (at the
time of writing this blog post). Then import
<a href="https://github.com/NixOS/nixpkgs/blob/master/pkgs/top-level/all-packages.nix">pkgs/top-level/all-packages.nix</a>.
From now on, we will refer to this set of packages as <strong>pkgs</strong>.</p>
<p>The <code>all-packages.nix</code> is then the file that composes all the packages.
Note the <code>pkgs/</code> subdirectory, while nixos is in the <code>nixos/</code>
subdirectory.</p>
<p>The <code>all-packages.nix</code> is a bit contrived. First of all, it's a
function. It accepts a couple of interesting parameters:</p>
<ul>
<li>
<p><code>system</code>: defaults to the current system</p>
</li>
<li>
<p><code>config</code>: defaults to null</p>
</li>
<li>
<p>others...</p>
</li>
</ul>
<p>The <strong>system</strong> parameter, as per comment in the expression, it's the
system for which the packages will be built. It allows for example to
install i686 packages on amd64 machines.</p>
<p>The <strong>config</strong> parameter is a simple attribute set. Packages can read
some of its values and change the behavior of some derivations.</p>
<h2 id="the-system-parameter"><a class="header" href="#the-system-parameter">The system parameter</a></h2>
<p>You will find this parameter in many other .nix expressions (e.g.
release expressions). The reason is that, given pkgs accepts a system
parameter, then whenever you want to import pkgs you also want to pass
through the value of system. E.g.:</p>
<p><code>myrelease.nix</code>:</p>
<pre><code>{ system ? builtins.currentSystem }:

let pkgs = import &lt;nixpkgs&gt; { inherit system; };
...
</code></pre>
<p>Why is it useful? With this parameter it's very easy to select a set of
packages for a particular system. For example:</p>
<pre><code>nix-build -A psmisc --argstr system i686-linux
</code></pre>
<p>This will build the psmisc derivation for i686-linux instead of
x86_64-linux. This concept is very similar to multi-arch of Debian.</p>
<p>The setup for cross compiling is also in <code>nixpkgs</code>, however it's a
little contrived to talk about it and I don't know much of it either.</p>
<h2 id="the-config-parameter"><a class="header" href="#the-config-parameter">The config parameter</a></h2>
<p>I'm sure on the wiki or other manuals you've read about
<code>~/.config/nixpkgs/config.nix</code> (previously <code>~/.nixpkgs/config.nix</code>) and
I'm sure you've wondered whether that's hardcoded in nix. It's not,
it's in
<a href="https://github.com/NixOS/nixpkgs/blob/32c523914fdb8bf9cc7912b1eba023a8daaae2e8/pkgs/top-level/impure.nix#L28">nixpkgs</a>.</p>
<p>The <code>all-packages.nix</code> expression accepts the <code>config</code> parameter. If
it's <code>null</code>, then it reads the <code>NIXPKGS_CONFIG</code> environment variable.
If not specified, <code>nixpkgs</code> will pick
<code>$HOME/.config/nixpkgs/config.nix</code>.</p>
<p>After determining <code>config.nix</code>, it will be imported as a nix expression,
and that will be the value of <code>config</code> (in case it hasn't been passed
as parameter to import <code>&lt;nixpkgs&gt;</code>).</p>
<p>The <code>config</code> is available in the resulting repository:</p>
<pre><code>$ nix repl
nix-repl&gt; pkgs = import &lt;nixpkgs&gt; {}
nix-repl&gt; pkgs.config
{ }
nix-repl&gt; pkgs = import &lt;nixpkgs&gt; { config = { foo = "bar"; }; }
nix-repl&gt; pkgs.config
{ foo = "bar"; }
</code></pre>
<p>What attributes go in <code>config</code> is a matter of convenience and
conventions.</p>
<p>For example, <code>config.allowUnfree</code> is an attribute that forbids building
packages that have an unfree license by default. The <code>config.pulseaudio</code>
setting tells whether to build packages with pulseaudio support or not
where applicable and when the derivation obeys to the setting.</p>
<h2 id="about-nix-functions"><a class="header" href="#about-nix-functions">About .nix functions</a></h2>
<p>A <code>.nix</code> file contains a nix expression. Thus it can also be a function.
I remind you that <code>nix-build</code> expects the expression to return a
derivation. Therefore it's natural to return straight a derivation from
a <code>.nix</code> file. However, it's also very natural for the <code>.nix</code> file to
accept some parameters, in order to tweak the derivation being returned.</p>
<p>In this case, nix does a trick:</p>
<ul>
<li>
<p>If the expression is a derivation, build it.</p>
</li>
<li>
<p>If the expression is a function, call it and build the resulting
derivation.</p>
</li>
</ul>
<p>For example you can nix-build the <code>.nix</code> file below:</p>
<pre><code>{ pkgs ? import &lt;nixpkgs&gt; {} }:

pkgs.psmisc
</code></pre>
<p>Nix is able to call the function because the pkgs parameter has a
default value. This allows you to pass a different value for pkgs using
the <code>--arg</code> option.</p>
<p>Does it work if you have a function returning a function that returns a
derivation? No, Nix only calls the function it encounters once.</p>
<h2 id="conclusion-12"><a class="header" href="#conclusion-12">Conclusion</a></h2>
<p>We've unleashed the <code>&lt;nixpkgs&gt;</code> repository. It's a function that
accepts some parameters, and returns the set of all packages. Due to
laziness, only the accessed derivations will be built.</p>
<p>You can use this repository to build your own packages as we've seen in
the previous pill when creating our own repository.</p>
<p>Lately I'm a little busy with the NixOS 14.11 release and other stuff,
and I'm also looking toward migrating from blogger to a more
coder-oriented blogging platform. So sorry for the delayed and shorter
pills :)</p>
<h2 id="next-pill-15"><a class="header" href="#next-pill-15">Next pill</a></h2>
<p>...we will talk about overriding packages in the <code>nixpkgs</code> repository.
What if you want to change some options of a library and let all other
packages pick the new library? One possibility is to use, like described
above, the <code>config</code> parameter when applicable. The other possibility is
to override derivations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nixpkgs-overriding-packages"><a class="header" href="#nixpkgs-overriding-packages">Nixpkgs Overriding Packages</a></h1>
<p>Welcome to the 17th Nix pill. In the previous
<a href="16-nixpkgs-parameters.html">16th</a> pill we have started to dive into the
<a href="http://github.com/NixOS/nixpkgs">nixpkgs repository</a>. <code>Nixpkgs</code> is a
function, and we've looked at some parameters like <code>system</code> and
<code>config</code>.</p>
<p>Today we'll talk about a special attribute: <code>config.packageOverrides</code>.
Overriding packages in a set with fixed point can be considered another
design pattern in nixpkgs.</p>
<h2 id="overriding-a-package"><a class="header" href="#overriding-a-package">Overriding a package</a></h2>
<p>Recall the override design pattern from the <a href="14-override-design-pattern.html">nix pill
14</a>. Instead of calling a function with
parameters directly, we make the call (function + parameters)
overridable.</p>
<p>We put the override function in the returned attribute set of the
original function call.</p>
<p>Take for example graphviz. It has an input parameter xorg. If it's
null, then graphviz will build without X support.</p>
<pre><code>$ nix repl
nix-repl&gt; :l &lt;nixpkgs&gt;
Added 4360 variables.
nix-repl&gt; :b graphviz.override { withXorg = false; }
</code></pre>
<p>This will build graphviz without X support, it's as simple as that.</p>
<p>However, let's say a package <code>P</code> depends on graphviz, how do we make
<code>P</code> depend on the new graphviz without X support?</p>
<h2 id="in-an-imperative-world"><a class="header" href="#in-an-imperative-world">In an imperative world...</a></h2>
<p>...you could do something like this:</p>
<pre><code>pkgs = import &lt;nixpkgs&gt; {};
pkgs.graphviz = pkgs.graphviz.override { withXorg = false; };
build(pkgs.P)
</code></pre>
<p>Given <code>pkgs.P</code> depends on <code>pkgs.graphviz</code>, it's easy to build <code>P</code> with
the replaced graphviz. In a pure functional language it's not that easy
because you can assign to variables only once.</p>
<h2 id="fixed-point"><a class="header" href="#fixed-point">Fixed point</a></h2>
<p>The fixed point with lazy evaluation is crippling but about necessary in
a language like Nix. It lets us achieve something similar to what we'd
do imperatively.</p>
<p>Follows the definition of fixed point in
<a href="https://github.com/NixOS/nixpkgs/blob/f224a4f1b32b3e813783d22de54e231cd8ea2448/lib/fixed-points.nix#L19">nixpkgs</a>:</p>
<pre><code>{
  # Take a function and evaluate it with its own returned value.
  fix =
    f:
    let
      result = f result;
    in
    result;
}
</code></pre>
<p>It's a function that accepts a function <code>f</code>, calls <code>f result</code> on the
result just returned by <code>f result</code> and returns it. In other words it's
<code>f(f(f(....</code></p>
<p>At first sight, it's an infinite loop. With lazy evaluation it isn't,
because the call is done only when needed.</p>
<pre><code>nix-repl&gt; fix = f: let result = f result; in result
nix-repl&gt; pkgs = self: { a = 3; b = 4; c = self.a+self.b; }
nix-repl&gt; fix pkgs
{ a = 3; b = 4; c = 7; }
</code></pre>
<p>Without the <code>rec</code> keyword, we were able to refer to <code>a</code> and <code>b</code> of the
same set.</p>
<ul>
<li>
<p>First <code>pkgs</code> gets called with an unevaluated thunk <code>(pkgs(pkgs(...)</code></p>
</li>
<li>
<p>To set the value of <code>c</code> then <code>self.a</code> and <code>self.b</code> are evaluated.</p>
</li>
<li>
<p>The <code>pkgs</code> function gets called again to get the value of <code>a</code> and
<code>b</code>.</p>
</li>
</ul>
<p>The trick is that <code>c</code> is not needed to be evaluated in the inner call,
thus it doesn't go in an infinite loop.</p>
<p>Won't go further with the explanation here. A good post about fixed
point and Nix can be <a href="http://r6.ca/blog/20140422T142911Z.html">found
here</a>.</p>
<h3 id="overriding-a-set-with-fixed-point"><a class="header" href="#overriding-a-set-with-fixed-point">Overriding a set with fixed point</a></h3>
<p>Given that <code>self.a</code> and <code>self.b</code> refer to the passed set and not to the
literal set in the function, we're able to override both <code>a</code> and <code>b</code>
and get a new value for <code>c</code>:</p>
<pre><code>nix-repl&gt; overrides = { a = 1; b = 2; }
nix-repl&gt; let newpkgs = pkgs (newpkgs // overrides); in newpkgs
{ a = 3; b = 4; c = 3; }
nix-repl&gt; let newpkgs = pkgs (newpkgs // overrides); in newpkgs // overrides
{ a = 1; b = 2; c = 3; }
</code></pre>
<p>In the first case we computed pkgs with the overrides, in the second
case we also included the overridden attributes in the result.</p>
<h2 id="overriding-nixpkgs-packages"><a class="header" href="#overriding-nixpkgs-packages">Overriding nixpkgs packages</a></h2>
<p>We've seen how to override attributes in a set such that they get
recursively picked by dependent attributes. This approach can be used
for derivations too, after all <code>nixpkgs</code> is a giant set of attributes
that depend on each other.</p>
<p>To do this, <code>nixpkgs</code> offers <code>config.packageOverrides</code>. So <code>nixpkgs</code>
returns a fixed point of the package set, and <code>packageOverrides</code> is used
to inject the overrides.</p>
<p>Create a <code>config.nix</code> file like this somewhere:</p>
<pre><code>{
  packageOverrides = pkgs: {
    graphviz = pkgs.graphviz.override {
      # disable xorg support
      withXorg = false;
    };
  };
}
</code></pre>
<p>Now we can build e.g. asciidoc-full and it will automatically use the
overridden graphviz:</p>
<pre><code>nix-repl&gt; pkgs = import &lt;nixpkgs&gt; { config = import ./config.nix; }
nix-repl&gt; :b pkgs.asciidoc-full
</code></pre>
<p>Note how we pass the <code>config</code> with <code>packageOverrides</code> when importing
<code>nixpkgs</code>. Then <code>pkgs.asciidoc-full</code> is a derivation that has graphviz
input (<code>pkgs.asciidoc</code> is the lighter version and doesn't use graphviz
at all).</p>
<p>Since there's no version of asciidoc with graphviz without X support in
the binary cache, Nix will recompile the needed stuff for you.</p>
<h2 id="the-confignixpkgsconfignix-file"><a class="header" href="#the-confignixpkgsconfignix-file">The ~/.config/nixpkgs/config.nix file</a></h2>
<p>In the previous pill we already talked about this file. The above
<code>config.nix</code> that we just wrote could be the content of
<code>~/.config/nixpkgs/config.nix</code> (or the deprecated location
<code>~/.nixpkgs/config.nix</code>).</p>
<p>Instead of passing it explicitly whenever we import <code>nixpkgs</code>, it will
be automatically <a href="https://github.com/NixOS/nixpkgs/blob/32c523914fdb8bf9cc7912b1eba023a8daaae2e8/pkgs/top-level/impure.nix#L28">imported by
nixpkgs</a>.</p>
<h2 id="conclusion-13"><a class="header" href="#conclusion-13">Conclusion</a></h2>
<p>We've learned about a new design pattern: using fixed point for
overriding packages in a package set.</p>
<p>Whereas in an imperative setting, like with other package managers, a
library is installed replacing the old version and applications will use
it, in Nix it's not that straight and simple. But it's more precise.</p>
<p>Nix applications will depend on specific versions of libraries, hence
the reason why we have to recompile asciidoc to use the new graphviz
library.</p>
<p>The newly built asciidoc will depend on the new graphviz, and old
asciidoc will keep using the old graphviz undisturbed.</p>
<h2 id="next-pill-16"><a class="header" href="#next-pill-16">Next pill</a></h2>
<p>...we will stop studying <code>nixpkgs</code> for a moment and talk about store
paths. How does Nix compute the path in the store where to place the
result of builds? How to add files to the store for which we have an
integrity hash?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nix-store-paths"><a class="header" href="#nix-store-paths">Nix Store Paths</a></h1>
<p>Welcome to the 18th Nix pill. In the previous
<a href="17-nixpkgs-overriding-packages.html">17th</a> pill we have scratched the surface
of the <code>nixpkgs</code> repository structure. It is a set of packages, and
it's possible to override such packages so that all other packages will
use the overrides.</p>
<p>Before reading existing derivations, I'd like to talk about store paths
and how they are computed. In particular we are interested in fixed
store paths that depend on an integrity hash (e.g. a sha256), which is
usually applied to source tarballs.</p>
<p>The way store paths are computed is a little contrived, mostly due to
historical reasons. Our reference will be the <a href="https://github.com/NixOS/nix/blob/07f992a74b64f4376d5b415d0042babc924772f3/src/libstore/store-api.cc#L197">Nix source
code</a>.</p>
<h2 id="source-paths"><a class="header" href="#source-paths">Source paths</a></h2>
<p>Let's start simple. You know nix allows relative paths to be used, such
that the file or directory is stored in the nix store, that is
<code>./myfile</code> gets stored into <code>/nix/store/.......</code> We want to understand
how is the store path generated for such a file:</p>
<pre><code>$ echo mycontent &gt; myfile
</code></pre>
<p>I remind you, the simplest derivation you can write has a <code>name</code>, a
<code>builder</code> and the <code>system</code>:</p>
<pre><code>$ nix repl
nix-repl&gt; derivation { system = "x86_64-linux"; builder = ./myfile; name = "foo"; }
«derivation /nix/store/y4h73bmrc9ii5bxg6i7ck6hsf5gqv8ck-foo.drv»
</code></pre>
<p>Now inspect the .drv to see where is <code>./myfile</code> being stored:</p>
<pre><code>$ nix derivation show /nix/store/y4h73bmrc9ii5bxg6i7ck6hsf5gqv8ck-foo.drv
{
  "/nix/store/y4h73bmrc9ii5bxg6i7ck6hsf5gqv8ck-foo.drv": {
    "outputs": {
      "out": {
        "path": "/nix/store/hs0yi5n5nw6micqhy8l1igkbhqdkzqa1-foo"
      }
    },
    "inputSrcs": [
      "/nix/store/xv2iccirbrvklck36f1g7vldn5v58vck-myfile"
    ],
    "inputDrvs": {},
    "platform": "x86_64-linux",
    "builder": "/nix/store/xv2iccirbrvklck36f1g7vldn5v58vck-myfile",
    "args": [],
    "env": {
      "builder": "/nix/store/xv2iccirbrvklck36f1g7vldn5v58vck-myfile",
      "name": "foo",
      "out": "/nix/store/hs0yi5n5nw6micqhy8l1igkbhqdkzqa1-foo",
      "system": "x86_64-linux"
    }
  }
}
</code></pre>
<p>Great, how did nix decide to use <code>xv2iccirbrvklck36f1g7vldn5v58vck</code> ?
Keep looking at the nix comments.</p>
<p><strong>Note:</strong> doing <code>nix-store --add myfile</code> will store the file in the same
store path.</p>
<h3 id="step-1-compute-the-hash-of-the-file"><a class="header" href="#step-1-compute-the-hash-of-the-file">Step 1, compute the hash of the file</a></h3>
<p>The comments tell us to first compute the sha256 of the NAR
serialization of the file. Can be done in two ways:</p>
<pre><code>$ nix-hash --type sha256 myfile
2bfef67de873c54551d884fdab3055d84d573e654efa79db3c0d7b98883f9ee3
</code></pre>
<p>Or:</p>
<pre><code>$ nix-store --dump myfile|sha256sum
2bfef67de873c54551d884fdab3055d84d573e654efa79db3c0d7b98883f9ee3
</code></pre>
<p>In general, Nix understands two contents: flat for regular files, or
recursive for NAR serializations which can be anything.</p>
<h3 id="step-2-build-the-string-description"><a class="header" href="#step-2-build-the-string-description">Step 2, build the string description</a></h3>
<p>Then nix uses a special string which includes the hash, the path type
and the file name. We store this in another file:</p>
<pre><code>$ echo -n "source:sha256:2bfef67de873c54551d884fdab3055d84d573e654efa79db3c0d7b98883f9ee3:/nix/store:myfile" &gt; myfile.str
</code></pre>
<h3 id="step-3-compute-the-final-hash"><a class="header" href="#step-3-compute-the-final-hash">Step 3, compute the final hash</a></h3>
<p>Finally the comments tell us to compute the base-32 representation of
the first 160 bits (truncation) of a sha256 of the above string:</p>
<pre><code>$ nix-hash --type sha256 --truncate --base32 --flat myfile.str
xv2iccirbrvklck36f1g7vldn5v58vck
</code></pre>
<h2 id="output-paths"><a class="header" href="#output-paths">Output paths</a></h2>
<p>Output paths are usually generated for derivations. We use the above
example because it's simple. Even if we didn't build the derivation,
nix knows the out path <code>hs0yi5n5nw6micqhy8l1igkbhqdkzqa1</code>. This is
because the out path only depends on inputs.</p>
<p>It's computed in a similar way to source paths, except that the .drv is
hashed and the type of derivation is <code>output:out</code>. In case of multiple
outputs, we may have different <code>output:&lt;id&gt;</code>.</p>
<p>At the time nix computes the out path, the .drv contains an empty string
for each out path. So what we do is getting our .drv and replacing the
out path with an empty string:</p>
<pre><code>$ cp -f /nix/store/y4h73bmrc9ii5bxg6i7ck6hsf5gqv8ck-foo.drv myout.drv
$ sed -i 's,/nix/store/hs0yi5n5nw6micqhy8l1igkbhqdkzqa1-foo,,g' myout.drv
</code></pre>
<p>The <code>myout.drv</code> is the .drv state in which nix is when computing the out
path for our derivation:</p>
<pre><code>$ sha256sum myout.drv
1bdc41b9649a0d59f270a92d69ce6b5af0bc82b46cb9d9441ebc6620665f40b5  myout.drv
$ echo -n "output:out:sha256:1bdc41b9649a0d59f270a92d69ce6b5af0bc82b46cb9d9441ebc6620665f40b5:/nix/store:foo" &gt; myout.str
$ nix-hash --type sha256 --truncate --base32 --flat myout.str
hs0yi5n5nw6micqhy8l1igkbhqdkzqa1
</code></pre>
<p>Then nix puts that out path in the .drv, and that's it.</p>
<p>In case the .drv has input derivations, that is it references other
.drv, then such .drv paths are replaced by this same algorithm which
returns a hash.</p>
<p>In other words, you get a final .drv where every other .drv path is
replaced by its hash.</p>
<h2 id="fixed-output-paths"><a class="header" href="#fixed-output-paths">Fixed-output paths</a></h2>
<p>Finally, the other most used kind of path is when we know beforehand an
integrity hash of a file. This is usual for tarballs.</p>
<p>A derivation can take three special attributes: <code>outputHashMode</code>,
<code>outputHash</code> and <code>outputHashAlgo</code> which are well documented in the <a href="https://nixos.org/manual/nix/stable/expressions/advanced-attributes.html">nix
manual</a>.</p>
<p>The builder must create the out path and make sure its hash is the same
as the one declared with <code>outputHash</code>.</p>
<p>Let's say our builder should create a file whose contents is
<code>mycontent</code>:</p>
<pre><code>$ echo mycontent &gt; myfile
$ sha256sum myfile
f3f3c4763037e059b4d834eaf68595bbc02ba19f6d2a500dce06d124e2cd99bb  myfile
nix-repl&gt; derivation { name = "bar"; system = "x86_64-linux"; builder = "none"; outputHashMode = "flat"; outputHashAlgo = "sha256"; outputHash = "f3f3c4763037e059b4d834eaf68595bbc02ba19f6d2a500dce06d124e2cd99bb"; }
«derivation /nix/store/ymsf5zcqr9wlkkqdjwhqllgwa97rff5i-bar.drv»
</code></pre>
<p>Inspect the .drv and see that it also stored the fact that it's a
fixed-output derivation with sha256 algorithm, compared to the previous
examples:</p>
<pre><code>$ nix derivation show /nix/store/ymsf5zcqr9wlkkqdjwhqllgwa97rff5i-bar.drv
{
  "/nix/store/ymsf5zcqr9wlkkqdjwhqllgwa97rff5i-bar.drv": {
    "outputs": {
      "out": {
        "path": "/nix/store/a00d5f71k0vp5a6klkls0mvr1f7sx6ch-bar",
        "hashAlgo": "sha256",
        "hash": "f3f3c4763037e059b4d834eaf68595bbc02ba19f6d2a500dce06d124e2cd99bb"
      }
    },
[...]
}
</code></pre>
<p>It doesn't matter which input derivations are being used, the final out
path must only depend on the declared hash.</p>
<p>What nix does is to create an intermediate string representation of the
fixed-output content:</p>
<pre><code>$ echo -n "fixed:out:sha256:f3f3c4763037e059b4d834eaf68595bbc02ba19f6d2a500dce06d124e2cd99bb:" &gt; mycontent.str
$ sha256sum mycontent.str 
423e6fdef56d53251c5939359c375bf21ea07aaa8d89ca5798fb374dbcfd7639  myfile.str
</code></pre>
<p>Then proceed as it was a normal derivation output path:</p>
<pre><code>$ echo -n "output:out:sha256:423e6fdef56d53251c5939359c375bf21ea07aaa8d89ca5798fb374dbcfd7639:/nix/store:bar" &gt; myfile.str
$ nix-hash --type sha256 --truncate --base32 --flat myfile.str
a00d5f71k0vp5a6klkls0mvr1f7sx6ch
</code></pre>
<p>Hence, the store path only depends on the declared fixed-output hash.</p>
<h2 id="conclusion-14"><a class="header" href="#conclusion-14">Conclusion</a></h2>
<p>There are other types of store paths, but you get the idea. Nix first
hashes the contents, then creates a string description, and the final
store path is the hash of this string.</p>
<p>Also we've introduced some fundamentals, in particular the fact that
Nix knows beforehand the out path of a derivation since it only depends
on the inputs. We've also introduced fixed-output derivations which are
especially used by the nixpkgs repository for downloading and verifying
source tarballs.</p>
<h2 id="next-pill-17"><a class="header" href="#next-pill-17">Next pill</a></h2>
<p>...we will introduce <code>stdenv</code>. In the previous pills we rolled our own
<code>mkDerivation</code> convenience function for wrapping the builtin derivation,
but the <code>nixpkgs</code> repository also has its own convenience functions for
dealing with autotools projects and other build systems.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fundamentals-of-stdenv"><a class="header" href="#fundamentals-of-stdenv">Fundamentals of Stdenv</a></h1>
<p>Welcome to the 19th Nix pill. In the previous <a href="18-nix-store-paths.html">18th</a>
pill we dived into the algorithm used by Nix to compute the store paths,
and also introduced fixed-output store paths.</p>
<p>This time we will instead look into <code>nixpkgs</code>, in particular one of its
core derivations: <code>stdenv</code>.</p>
<p>The <code>stdenv</code> is not treated as a special derivation by Nix, but it's
very important for the <code>nixpkgs</code> repository. It serves as a base for
packaging software. It is used to pull in dependencies such as the GCC
toolchain, GNU make, core utilities, patch and diff utilities, and so
on: basic tools needed to compile a huge pile of software currently
present in <code>nixpkgs</code>.</p>
<h2 id="what-is-stdenv"><a class="header" href="#what-is-stdenv">What is stdenv?</a></h2>
<p>First of all, <code>stdenv</code> is a derivation, and it's a very simple one:</p>
<pre><code>$ nix-build '&lt;nixpkgs&gt;' -A stdenv
/nix/store/k4jklkcag4zq4xkqhkpy156mgfm34ipn-stdenv
$ ls -R result/
result/:
nix-support/  setup

result/nix-support:
propagated-user-env-packages
</code></pre>
<p>It has just two files: <code>/setup</code> and
<code>/nix-support/propagated-user-env-packages</code>. Don't worry about the
latter. It's empty, in fact. The important file is <code>/setup</code>.</p>
<p>How can this simple derivation pull in all of the toolchain and basic
tools needed to compile packages? Let's look at the runtime
dependencies:</p>
<pre><code>$ nix-store -q --references result
/nix/store/3a45nb37s0ndljp68228snsqr3qsyp96-bzip2-1.0.6
/nix/store/a457ywa1haa0sgr9g7a1pgldrg3s798d-coreutils-8.24
/nix/store/zmd4jk4db5lgxb8l93mhkvr3x92g2sx2-bash-4.3-p39
/nix/store/47sfpm2qclpqvrzijizimk4md1739b1b-gcc-wrapper-4.9.3
...
</code></pre>
<p>How can it be? The package must be referring to those other packages
somehow. In fact, they are hardcoded in the <code>/setup</code> file:</p>
<pre><code>$ head result/setup
export SHELL=/nix/store/zmd4jk4db5lgxb8l93mhkvr3x92g2sx2-bash-4.3-p39/bin/bash
initialPath="/nix/store/a457ywa1haa0sgr9g7a1pgldrg3s798d-coreutils-8.24 ..."
defaultNativeBuildInputs="/nix/store/sgwq15xg00xnm435gjicspm048rqg9y6-patchelf-0.8 ..."
</code></pre>
<h2 id="the-setup-file"><a class="header" href="#the-setup-file">The setup file</a></h2>
<p>Remember our generic <code>builder.sh</code> in <a href="08-generic-builders.html">Pill 8</a>? It
sets up a basic <code>PATH</code>, unpacks the source and runs the usual autotools
commands for us.</p>
<p>The <a href="https://github.com/NixOS/nixpkgs/blob/master/pkgs/stdenv/generic/setup.sh">stdenv setup
file</a>
is exactly that. It sets up several environment variables like <code>PATH</code>
and creates some helper bash functions to build a package. I invite you
to read it.</p>
<p>The hardcoded toolchain and utilities are used to initially fill up the
environment variables so that it's more pleasant to run common
commands, similar to what we did with our builder with <code>baseInputs</code> and
<code>buildInputs</code>.</p>
<p>The build with <code>stdenv</code> works in phases. Phases are like <code>unpackPhase</code>,
<code>configurePhase</code>, <code>buildPhase</code>, <code>checkPhase</code>, <code>installPhase</code>,
<code>fixupPhase</code>. You can see the default list in the <code>genericBuild</code>
function.</p>
<p>What <code>genericBuild</code> does is just run these phases. Default phases are
just bash functions. You can easily read them.</p>
<p>Every phase has hooks to run commands before and after the phase has
been executed. Phases can be overwritten, reordered, whatever, it's
just bash code.</p>
<p>How to use this file? Like our old builder. To test it, we enter a fake
empty derivation, source the <code>stdenv</code> <code>setup</code>, unpack the hello sources
and build it:</p>
<pre><code>$ nix-shell -E 'derivation { name = "fake"; builder = "fake"; system = "x86_64-linux"; }'
nix-shell$ unset PATH
nix-shell$ source /nix/store/k4jklkcag4zq4xkqhkpy156mgfm34ipn-stdenv/setup
nix-shell$ tar -xf hello-2.10.tar.gz
nix-shell$ cd hello-2.10
nix-shell$ configurePhase
...
nix-shell$ buildPhase
...
</code></pre>
<p><em>I unset <code>PATH</code> to further show that the <code>stdenv</code> is sufficiently
self-contained to build autotools packages that have no other
dependencies.</em></p>
<p>So we ran the <code>configurePhase</code> function and <code>buildPhase</code> function and
they worked. These bash functions should be self-explanatory. You can
read the code in the <code>setup</code> file.</p>
<h2 id="how-the-setup-file-is-built"><a class="header" href="#how-the-setup-file-is-built">How the setup file is built</a></h2>
<p>Until now we worked with plain bash scripts. What about the Nix side?
The <code>nixpkgs</code> repository offers a useful function, like we did with our
old builder. It is a wrapper around the raw derivation function which
pulls in the <code>stdenv</code> for us, and runs <code>genericBuild</code>. It's
<a href="https://github.com/NixOS/nixpkgs/blob/master/pkgs/stdenv/generic/make-derivation.nix">stdenv.mkDerivation</a>.</p>
<p>Note how <code>stdenv</code> is a derivation but it's also an attribute set which
contains some other attributes, like <code>mkDerivation</code>. Nothing fancy here,
just convenience.</p>
<p>Let's write a <code>hello.nix</code> expression using this newly discovered
<code>stdenv</code>:</p>
<pre><code>with import &lt;nixpkgs&gt; { };
stdenv.mkDerivation {
  name = "hello";
  src = ./hello-2.10.tar.gz;
}
</code></pre>
<p>Don't be scared by the <code>with</code> expression. It pulls the <code>nixpkgs</code>
repository into scope, so we can directly use <code>stdenv</code>. It looks very
similar to the hello expression in <a href="08-generic-builders.html">Pill 8</a>.</p>
<p>It builds, and runs fine:</p>
<pre><code>$ nix-build hello.nix
...
/nix/store/6y0mzdarm5qxfafvn2zm9nr01d1j0a72-hello
$ result/bin/hello
Hello, world!
</code></pre>
<h2 id="the-stdenvmkderivation-builder"><a class="header" href="#the-stdenvmkderivation-builder">The stdenv.mkDerivation builder</a></h2>
<p>Let's take a look at the builder used by <code>mkDerivation</code>. You can read
the code <a href="https://github.com/NixOS/nixpkgs/blob/master/pkgs/stdenv/generic/make-derivation.nix">here in
nixpkgs</a>:</p>
<pre><code>{
  # ...
  builder = attrs.realBuilder or shell;
  args =
    attrs.args or [
      "-e"
      (attrs.builder or ./default-builder.sh)
    ];
  stdenv = result;
  # ...
}
</code></pre>
<p>Also take a look at our old derivation wrapper in previous pills! The
builder is bash (that shell variable), the argument to the builder
(bash) is <code>default-builder.sh</code>, and then we add the environment variable
<code>$stdenv</code> in the derivation which is the <code>stdenv</code> derivation.</p>
<p>You can open
<a href="https://github.com/NixOS/nixpkgs/blob/master/pkgs/stdenv/generic/default-builder.sh">default-builder.sh</a>
and see what it does:</p>
<pre><code>source $stdenv/setup
genericBuild
</code></pre>
<p>It's what we did in <a href="10-developing-with-nix-shell.html">Pill 10</a> to make the
derivations <code>nix-shell</code> friendly. When entering the shell, the setup
file only sets up the environment without building anything. When doing
<code>nix-build</code>, it actually runs the build process.</p>
<p>To get a clear understanding of the environment variables, look at the
.drv of the hello derivation:</p>
<pre><code>$ nix derivation show $(nix-instantiate hello.nix)
warning: you did not specify '--add-root'; the result might be removed by the garbage collector
{
  "/nix/store/abwj50lycl0m515yblnrvwyydlhhqvj2-hello.drv": {
    "outputs": {
      "out": {
        "path": "/nix/store/6y0mzdarm5qxfafvn2zm9nr01d1j0a72-hello"
      }
    },
    "inputSrcs": [
      "/nix/store/9krlzvny65gdc8s7kpb6lkx8cd02c25b-default-builder.sh",
      "/nix/store/svc70mmzrlgq42m9acs0prsmci7ksh6h-hello-2.10.tar.gz"
    ],
    "inputDrvs": {
      "/nix/store/hcgwbx42mcxr7ksnv0i1fg7kw6jvxshb-bash-4.4-p19.drv": [
        "out"
      ],
      "/nix/store/sfxh3ybqh97cgl4s59nrpi78kgcc8f3d-stdenv-linux.drv": [
        "out"
      ]
    },
    "platform": "x86_64-linux",
    "builder": "/nix/store/q1g0rl8zfmz7r371fp5p42p4acmv297d-bash-4.4-p19/bin/bash",
    "args": [
      "-e",
      "/nix/store/9krlzvny65gdc8s7kpb6lkx8cd02c25b-default-builder.sh"
    ],
    "env": {
      "buildInputs": "",
      "builder": "/nix/store/q1g0rl8zfmz7r371fp5p42p4acmv297d-bash-4.4-p19/bin/bash",
      "configureFlags": "",
      "depsBuildBuild": "",
      "depsBuildBuildPropagated": "",
      "depsBuildTarget": "",
      "depsBuildTargetPropagated": "",
      "depsHostBuild": "",
      "depsHostBuildPropagated": "",
      "depsTargetTarget": "",
      "depsTargetTargetPropagated": "",
      "name": "hello",
      "nativeBuildInputs": "",
      "out": "/nix/store/6y0mzdarm5qxfafvn2zm9nr01d1j0a72-hello",
      "propagatedBuildInputs": "",
      "propagatedNativeBuildInputs": "",
      "src": "/nix/store/svc70mmzrlgq42m9acs0prsmci7ksh6h-hello-2.10.tar.gz",
      "stdenv": "/nix/store/6kz2vbh98s2r1pfshidkzhiy2s2qdw0a-stdenv-linux",
      "system": "x86_64-linux"
    }
  }
}
</code></pre>
<p>It's so short I decided to paste it entirely above. The builder is
bash, with <code>-e default-builder.sh</code> arguments. Then you can see the <code>src</code>
and <code>stdenv</code> environment variables.</p>
<p>The last bit, the <code>unpackPhase</code> in the setup, is used to unpack the
sources and enter the directory. Again, like we did in our old builder.</p>
<h2 id="conclusion-15"><a class="header" href="#conclusion-15">Conclusion</a></h2>
<p>The <code>stdenv</code> is the core of the <code>nixpkgs</code> repository. All packages use
the <code>stdenv.mkDerivation</code> wrapper instead of the raw derivation. It does
a bunch of operations for us and also sets up a pleasant build
environment.</p>
<p>The overall process is simple:</p>
<ul>
<li>
<p><code>nix-build</code></p>
</li>
<li>
<p><code>bash -e default-builder.sh</code></p>
</li>
<li>
<p><code>source $stdenv/setup</code></p>
</li>
<li>
<p><code>genericBuild</code></p>
</li>
</ul>
<p>That's it. Everything you need to know about the stdenv phases is in
the <a href="https://github.com/NixOS/nixpkgs/blob/master/pkgs/stdenv/generic/setup.sh">setup
file</a>.</p>
<p>Really, take your time to read that file. Don't forget that juicy docs
are also available in the <a href="http://nixos.org/nixpkgs/manual/#chap-stdenv">nixpkgs
manual</a>.</p>
<h2 id="next-pill-18"><a class="header" href="#next-pill-18">Next pill...</a></h2>
<p>...we will talk about how to add dependencies to our packages with
<code>buildInputs</code> and <code>propagatedBuildInputs</code>, and influence downstream
builds with setup hooks and env hooks. These concepts are crucial to how
<code>nixpkgs</code> packages are composed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-dependencies-and-hooks"><a class="header" href="#basic-dependencies-and-hooks">Basic Dependencies and Hooks</a></h1>
<p>Welcome to the 20th Nix pill. In the previous
<a href="19-fundamentals-of-stdenv.html">19th</a> pill we introduced Nixpkgs' stdenv,
including <code>setup.sh</code> script, <code>default-builder.sh</code> helper script, and
<code>stdenv.mkDerivation</code> builder. We focused on how stdenv is put together,
and how it's used, and a bit about the phases of <code>genericBuild</code>.</p>
<p>This time, we'll focus on the interaction of packages built with
<code>stdenv.mkDerivation</code>. Packages need to depend on each other, of course.
For this we have <code>buildInputs</code> and <code>propagatedBuildInputs</code> attributes.
We've also found that dependencies sometimes need to influence their
dependents in ways the dependents can't or shouldn't predict. For this
we have setup hooks and env hooks. Together, these 4 concepts support
almost all build-time package interactions.</p>
<div class="info">
Note: The complexity of the dependencies and hooks infrastructure has
increased, over time, to support cross compilation. Once you learn the
core concepts, you will be able to understand the extra complexity. As a
starting point, you might want to refer to nixpkgs commit
<a href="https://github.com/nixos/nixpkgs/tree/6675f0a52c0962042a1000c7f20e887d0d26ae25">6675f0a5</a>,
the last version of stdenv without cross-compilation complexity.
</div>
<h2 id="the-buildinputs-attribute"><a class="header" href="#the-buildinputs-attribute">The <code>buildInputs</code> Attribute</a></h2>
<p>For the simplest dependencies where the current package directly needs
another, we use the <code>buildInputs</code> attribute. This is exactly the pattern
used in our builder in <a href="08-generic-builders.html">Pill 8</a>. To demo this, let's
build GNU Hello, and then another package which provides a shell script
that <code>exec</code>s it.</p>
<pre><code>let

  nixpkgs = import &lt;nixpkgs&gt; { };

  inherit (nixpkgs) stdenv fetchurl which;

  actualHello = stdenv.mkDerivation {
    name = "hello-2.3";

    src = fetchurl {
      url = "mirror://gnu/hello/hello-2.3.tar.bz2";
      sha256 = "0c7vijq8y68bpr7g6dh1gny0bff8qq81vnp4ch8pjzvg56wb3js1";
    };
  };

  wrappedHello = stdenv.mkDerivation {
    name = "hello-wrapper";

    buildInputs = [
      actualHello
      which
    ];

    unpackPhase = "true";

    installPhase = ''
      mkdir -p "$out/bin"
      echo "#! ${stdenv.shell}" &gt;&gt; "$out/bin/hello"
      echo "exec $(which hello)" &gt;&gt; "$out/bin/hello"
      chmod 0755 "$out/bin/hello"
    '';
  };
in
wrappedHello
</code></pre>
<p>Notice that the wrappedHello derivation finds the <code>hello</code> binary from
the <code>PATH</code>. This works because stdenv contains something like:</p>
<pre><code>pkgs=""
for i in $buildInputs; do
    findInputs $i
done
</code></pre>
<p>where <code>findInputs</code> is defined like:</p>
<pre><code>findInputs() {
    local pkg=$1

    ## Don't need to repeat already processed package
    case $pkgs in
        *\ $pkg\ *)
            return 0
            ;;
    esac

    pkgs="$pkgs $pkg "

    ## More goes here in reality that we can ignore for now.
}
</code></pre>
<p>then after this is run:</p>
<pre><code>for i in $pkgs; do
    addToEnv $i
done
</code></pre>
<p>where <code>addToEnv</code> is defined like:</p>
<pre><code>addToEnv() {
    local pkg=$1

    if test -d $1/bin; then
        addToSearchPath _PATH $1/bin
    fi

    ## More goes here in reality that we can ignore for now.
}
</code></pre>
<p>The <code>addToSearchPath</code> call adds <code>$1/bin</code> to <code>_PATH</code> if the former exists
(code
<a href="https://github.com/NixOS/nixpkgs/blob/6675f0a52c0962042a1000c7f20e887d0d26ae25/pkgs/stdenv/generic/setup.sh#L60-L73">here</a>).
Once all the packages in <code>buildInputs</code> have been processed, then content
of <code>_PATH</code> is added to <code>PATH</code>, as follows:</p>
<pre><code>PATH="${_PATH-}${_PATH:+${PATH:+:}}$PATH"
</code></pre>
<p>With the real <code>hello</code> on the <code>PATH</code>, the <code>installPhase</code> should hopefully
make sense.</p>
<h2 id="the-propagatedbuildinputs-attribute"><a class="header" href="#the-propagatedbuildinputs-attribute">The <code>propagatedBuildInputs</code> Attribute</a></h2>
<p>The <code>buildInputs</code> covers direct dependencies, but what about indirect
dependencies where one package needs a second package which needs a
third? Nix itself handles this just fine, understanding various
dependency closures as covered in previous builds. But what about the
conveniences that <code>buildInputs</code> provides, namely accumulating in <code>pkgs</code>
environment variable and inclusion of <code>pkg/bin</code> directories on the
<code>PATH</code>? For this, stdenv provides the <code>propagatedBuildInputs</code>:</p>
<pre><code>let

  nixpkgs = import &lt;nixpkgs&gt; { };

  inherit (nixpkgs) stdenv fetchurl which;

  actualHello = stdenv.mkDerivation {
    name = "hello-2.3";

    src = fetchurl {
      url = "mirror://gnu/hello/hello-2.3.tar.bz2";
      sha256 = "0c7vijq8y68bpr7g6dh1gny0bff8qq81vnp4ch8pjzvg56wb3js1";
    };
  };

  intermediary = stdenv.mkDerivation {
    name = "middle-man";

    propagatedBuildInputs = [ actualHello ];

    unpackPhase = "true";

    installPhase = ''
      mkdir -p "$out"
    '';
  };

  wrappedHello = stdenv.mkDerivation {
    name = "hello-wrapper";

    buildInputs = [
      intermediary
      which
    ];

    unpackPhase = "true";

    installPhase = ''
      mkdir -p "$out/bin"
      echo "#! ${stdenv.shell}" &gt;&gt; "$out/bin/hello"
      echo "exec $(which hello)" &gt;&gt; "$out/bin/hello"
      chmod 0755 "$out/bin/hello"
    '';
  };
in
wrappedHello
</code></pre>
<p>See how the intermediate package has a <code>propagatedBuildInputs</code>
dependency, but the wrapper only needs a <code>buildInputs</code> dependency on the
intermediary.</p>
<p>How does this work? You might think we do something in Nix, but actually
it's done not at eval time but at build time in bash. let's look at
part of the <code>fixupPhase</code> of stdenv:</p>
<pre><code>fixupPhase() {

    ## Elided

    if test -n "$propagatedBuildInputs"; then
        mkdir -p "$out/nix-support"
        echo "$propagatedBuildInputs" &gt; "$out/nix-support/propagated-build-inputs"
    fi

    ## Elided

}
</code></pre>
<p>This dumps the propagated build inputs in a so-named file in
<code>$out/nix-support/</code>. Then, back in <code>findInputs</code> look at the lines at the
bottom we elided before:</p>
<pre><code>findInputs() {
    local pkg=$1

    ## More goes here in reality that we can ignore for now.

    if test -f $pkg/nix-support/propagated-build-inputs; then
        for i in $(cat $pkg/nix-support/propagated-build-inputs); do
            findInputs $i
        done
    fi
}
</code></pre>
<p>See how <code>findInputs</code> is actually recursive, looking at the propagated
build inputs of each dependency, and those dependencies' propagated
build inputs, etc.</p>
<p>We actually simplified the <code>findInputs</code> call site from before;
<code>propagatedBuildInputs</code> is also looped over in reality:</p>
<pre><code>pkgs=""
for i in $buildInputs $propagatedBuildInputs; do
    findInputs $i
done
</code></pre>
<p>This demonstrates an important point. For the <em>current</em> package alone,
it doesn't matter whether a dependency is propagated or not. It will be
processed the same way: called with <code>findInputs</code> and <code>addToEnv</code>. (The
packages discovered by <code>findInputs</code>, which are also accumulated in
<code>pkgs</code> and passed to <code>addToEnv</code>, are also the same in both cases.)
Downstream however, it certainly does matter because only the propagated
immediate dependencies are put in the
<code>$out/nix-support/propagated-build-inputs</code>.</p>
<h2 id="setup-hooks"><a class="header" href="#setup-hooks">Setup Hooks</a></h2>
<p>As we mentioned above, sometimes dependencies need to influence the
packages that use them in ways other than just <em>being</em> a dependency.
<sup class="footnote-reference"><a href="#1">1</a></sup> <code>propagatedBuildInputs</code> can actually be seen as an example of this:
packages using that are effectively "injecting" those dependencies as
extra <code>buildInputs</code> in their downstream dependents. But in general, a
dependency might affect the packages it depends on in arbitrary ways.
<em>Arbitrary</em> is the key word here. We could teach <code>setup.sh</code> things about
upstream packages like <code>pkg/nix-support/propagated-build-inputs</code>, but
not arbitrary interactions.</p>
<p>Setup hooks are the basic building block we have for this. In nixpkgs, a
"hook" is basically a bash callback, and a setup hook is no exception.
Let's look at the last part of <code>findInputs</code> we haven't covered:</p>
<pre><code>findInputs() {
    local pkg=$1

    ## More goes here in reality that we can ignore for now.

    if test -f $pkg/nix-support/setup-hook; then
        source $pkg/nix-support/setup-hook
    fi

    ## More goes here in reality that we can ignore for now.

}
</code></pre>
<p>If a package includes the path <code>pkg/nix-support/setup-hook</code>, it will be
sourced by any stdenv-based build including that as a dependency.</p>
<p>This is strictly more general than any of the other mechanisms
introduced in this chapter. For example, try writing a setup hook that
has the same effect as a <em>propagatedBuildInputs</em> entry. One can almost
think of this as an escape hatch around Nix's normal isolation
guarantees, and the principle that dependencies are immutable and inert.
We're not actually doing something unsafe or modifying dependencies,
but we are allowing arbitrary ad-hoc behavior. For this reason,
setup-hooks should only be used as a last resort.</p>
<h2 id="environment-hooks"><a class="header" href="#environment-hooks">Environment Hooks</a></h2>
<p>As a final convenience, we have environment hooks. Recall in <a href="12-inputs-design-pattern.html">Pill
12</a> how we created <code>NIX_CFLAGS_COMPILE</code> for <code>-I</code>
flags and <code>NIX_LDFLAGS</code> for <code>-L</code> flags, in a similar manner to how we
prepared the <code>PATH</code>. One point of ugliness was how anti-modular this
was. It makes sense to build the <code>PATH</code> in a generic builder, because
the <code>PATH</code> is used by the shell, and the generic builder is
intrinsically tied to the shell. But <code>-I</code> and <code>-L</code> flags are only
relevant to the C compiler. The stdenv isn't wedded to including a C
compiler (though it does by default), and there are other compilers too
which may take completely different flags.</p>
<p>As a first step, we can move that logic to a setup hook on the C
compiler; indeed that's just what we do in CC Wrapper. <sup class="footnote-reference"><a href="#2">2</a></sup> But this
pattern comes up fairly often, so somebody decided to add some helper
support to reduce boilerplate.</p>
<p>The other half of <code>addToEnv</code> is:</p>
<pre><code>addToEnv() {
    local pkg=$1

    ## More goes here in reality that we can ignore for now.

    # Run the package-specific hooks set by the setup-hook scripts.
    for i in "${envHooks[@]}"; do
        $i $pkg
    done
}
</code></pre>
<p>Functions listed in <code>envHooks</code> are applied to every package passed to
<code>addToEnv</code>. One can write a setup hook like:</p>
<pre><code>anEnvHook() {
    local pkg=$1

    echo "I'm depending on \"$pkg\""
}

envHooks+=(anEnvHook)
</code></pre>
<p>and if one dependency has that setup hook then all of them will be so
<code>echo</code>ed. Allowing dependencies to learn about their <em>sibling</em>
dependencies is exactly what compilers need.</p>
<h2 id="next-pill-19"><a class="header" href="#next-pill-19">Next pill...</a></h2>
<p>...I'm not sure! We could talk about the additional dependency types
and hooks which cross compilation necessitates, building on our
knowledge here to cover stdenv as it works today. We could talk about
how nixpkgs is bootstrapped. Or we could talk about how <code>localSystem</code>
and <code>crossSystem</code> are elaborated into the <code>buildPlatform</code>,
<code>hostPlatform</code>, and <code>targetPlatform</code> each bootstrapping stage receives.
Let us know which most interests you!</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>We can now be precise and consider what <code>addToEnv</code> does alone the
minimal treatment of a dependency: i.e. a package that is <em>just</em> a
dependency would <em>only</em> have <code>addToEnv</code> applied to it.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>It was called <a href="https://github.com/NixOS/nixpkgs/tree/6675f0a52c0962042a1000c7f20e887d0d26ae25/pkgs/build-support/gcc-wrapper">GCC
Wrapper</a>
in the version of nixpkgs suggested for following along in this
pill; Darwin and Clang support hadn't yet motivated the rename.</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
